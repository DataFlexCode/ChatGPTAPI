Compiling Program: C:\Projects\ChatGPTAPI\AppSrc\ChatGPT.src
Memory Available: 11575369728
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.x64.pkd    (C:\Program Files\DataFlex 23.0\Pkg\dfallent.x64.pkd)
73406>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJStandardCommandBarSystem.pkg)
73406>>>// these are all the packages used in a standard MDI menubar/toolbar system
73406>>>
73406>>>Use cCJCommandBarSystem.pkg
73406>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJStandardMenuItemClasses.pkg)
73406>>>>>Use Dfpanel.pkg
73406>>>>>Use cCJCommandBarSystem.pkg
73406>>>>>Use LanguageText.pkg
73406>>>>>
73406>>>>>
73406>>>>>Class cCJUndoMenuItem is a cCJMenuItem
73407>>>>>    
73407>>>>>    Procedure Construct_Object
73409>>>>>        Forward Send Construct_Object
73411>>>>>        Set psCaption   to C_$CaptionUndo
73412>>>>>        Set psToolTip to C_$ToolTipUndo
73413>>>>>        Set psDescription to C_$DescUndo
73414>>>>>        Set psImage to "ActionUndo.ico"
73415>>>>>        Set pbActiveUpdate to True
73416>>>>>        Set psCategory to C_$CategoryEdit
73417>>>>>        Set psShortcut to C_$Key_Ctrl_Z
73418>>>>>    End_Procedure
73419>>>>>    
73419>>>>>    Procedure OnExecute Variant vCommandBarControl
73421>>>>>        Send Undo of (focus(Self))
73422>>>>>    End_Procedure
73423>>>>>    
73423>>>>>    Function IsEnabled Returns Boolean
73425>>>>>        Boolean bEnabled
73425>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
73426>>>>>        Function_Return bEnabled
73427>>>>>    End_Function
73428>>>>>    
73428>>>>>End_Class
73429>>>>>
73429>>>>>
73429>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
73430>>>>>    
73430>>>>>    Procedure Construct_Object
73432>>>>>        Forward Send Construct_Object
73434>>>>>        Set psCaption   to C_$CaptionDelete
73435>>>>>        Set psToolTip to C_$ToolTipDelete
73436>>>>>        Set psDescription to C_$DescDelete
73437>>>>>        Set psImage to "actionDelete.ico"
73438>>>>>        Set psShortcut to C_$Key_Delete
73439>>>>>        Set pbActiveUpdate to True
73440>>>>>        Set psCategory to C_$CategoryEdit
73441>>>>>    End_Procedure
73442>>>>>    
73442>>>>>    
73442>>>>>    Procedure OnExecute Variant vCommandBarControl
73444>>>>>        Send Delete of (focus(Self))
73445>>>>>    End_Procedure
73446>>>>>    
73446>>>>>    Function IsEnabled Returns Boolean
73448>>>>>        Boolean bEnabled
73448>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
73449>>>>>        Function_Return bEnabled
73450>>>>>    End_Function
73451>>>>>    
73451>>>>>End_Class
73452>>>>>
73452>>>>>
73452>>>>>Class cCJCutMenuItem is a cCJMenuItem
73453>>>>>    
73453>>>>>    Procedure Construct_Object
73455>>>>>        Forward Send Construct_Object
73457>>>>>        Set psCaption   to C_$CaptionCut
73458>>>>>        Set psToolTip to C_$TooltipCut
73459>>>>>        Set psDescription to C_$DescCut
73460>>>>>        Set psImage to "actionCut.ico"
73461>>>>>        Set psShortcut to C_$Key_Ctrl_X
73462>>>>>        Set pbActiveUpdate to True
73463>>>>>        Set psCategory to C_$CategoryEdit
73464>>>>>    End_Procedure
73465>>>>>    
73465>>>>>    
73465>>>>>    Procedure OnExecute Variant vCommandBarControl
73467>>>>>        Send Cut of (focus(Self))
73468>>>>>    End_Procedure
73469>>>>>    
73469>>>>>    Function IsEnabled Returns Boolean
73471>>>>>        Boolean bEnabled
73471>>>>>        Get CanCut of (Focus(Self)) to bEnabled
73472>>>>>        Function_Return bEnabled
73473>>>>>    End_Function
73474>>>>>    
73474>>>>>End_Class
73475>>>>>
73475>>>>>
73475>>>>>Class cCJCopyMenuItem is a cCJMenuItem
73476>>>>>    
73476>>>>>    Procedure Construct_Object
73478>>>>>        Forward Send Construct_Object
73480>>>>>        Set psCaption   to C_$CaptionCopy
73481>>>>>        Set psToolTip to C_$ToolTipCopy
73482>>>>>        Set psDescription to C_$DescCopy
73483>>>>>        Set psImage to "actionCopy.ico"
73484>>>>>        Set psShortcut to C_$Key_Ctrl_C
73485>>>>>        Set pbActiveUpdate to True
73486>>>>>        Set psCategory to C_$CategoryEdit
73487>>>>>    End_Procedure
73488>>>>>    
73488>>>>>    
73488>>>>>    Procedure OnExecute Variant vCommandBarControl
73490>>>>>        Send Copy of (focus(Self))
73491>>>>>    End_Procedure
73492>>>>>    
73492>>>>>    Function IsEnabled Returns Boolean
73494>>>>>        Boolean bEnabled
73494>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
73495>>>>>        Function_Return bEnabled
73496>>>>>    End_Function
73497>>>>>    
73497>>>>>End_Class
73498>>>>>
73498>>>>>
73498>>>>>Class cCJPasteMenuItem is a cCJMenuItem
73499>>>>>    
73499>>>>>    Procedure Construct_Object
73501>>>>>        Forward Send Construct_Object
73503>>>>>        Set psCaption   to C_$CaptionPaste
73504>>>>>        Set psToolTip to C_$ToolTipPaste
73505>>>>>        Set psDescription to C_$DescPaste
73506>>>>>        Set psImage to "actionPaste.ico"
73507>>>>>        Set pbActiveUpdate to True
73508>>>>>        Set psShortcut to C_$Key_Ctrl_V
73509>>>>>        Set psCategory to C_$CategoryEdit
73510>>>>>    End_Procedure
73511>>>>>    
73511>>>>>    
73511>>>>>    Procedure OnExecute Variant vCommandBarControl
73513>>>>>        Send Paste of (focus(Self))
73514>>>>>    End_Procedure
73515>>>>>    
73515>>>>>    Function IsEnabled Returns Boolean
73517>>>>>        Boolean bEnabled
73517>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
73518>>>>>        Function_Return bEnabled
73519>>>>>    End_Function
73520>>>>>    
73520>>>>>End_Class
73521>>>>>
73521>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
73522>>>>>    
73522>>>>>    Procedure Construct_Object
73524>>>>>        Forward Send Construct_Object
73526>>>>>        Set psCaption   to C_$CaptionSelectAll
73527>>>>>        Set psToolTip to C_$ToolTipSelectAll
73528>>>>>        Set psDescription to C_$DescSelectAll
73529>>>>>        Set pbActiveUpdate to True
73530>>>>>        Set psShortcut to C_$Key_Ctrl_A
73531>>>>>        Set psCategory to C_$CategoryEdit
73532>>>>>    End_Procedure
73533>>>>>    
73533>>>>>    
73533>>>>>    Procedure OnExecute Variant vCommandBarControl
73535>>>>>        Send Select_All of (focus(Self))
73536>>>>>    End_Procedure
73537>>>>>    
73537>>>>>    Function IsEnabled Returns Boolean
73539>>>>>        Boolean bEnabled
73539>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
73540>>>>>        Function_Return bEnabled
73541>>>>>    End_Function
73542>>>>>    
73542>>>>>End_Class
73543>>>>>
73543>>>>>
73543>>>>>Class cCJExitMenuItem is a cCJMenuItem
73544>>>>>    
73544>>>>>    Procedure Construct_Object
73546>>>>>        Forward Send Construct_Object
73548>>>>>        Set psCaption to C_$CaptionExit
73549>>>>>        Set psToolTip to C_$ToolTipExit
73550>>>>>        Set psDescription to C_$ToolTipExit
73551>>>>>        Set psShortcut to C_$Key_Alt_F4
73552>>>>>        Set psCategory to C_$CategoryFile
73553>>>>>    End_Procedure
73554>>>>>    
73554>>>>>    Procedure OnExecute Variant vCommandBarControl
73556>>>>>        Send Exit_Application of Desktop
73557>>>>>    End_Procedure
73558>>>>>    
73558>>>>>End_Class
73559>>>>>
73559>>>>>Class cCJHelpMenuItem is a cCJMenuItem
73560>>>>>    
73560>>>>>    Procedure Construct_Object
73562>>>>>        Forward Send Construct_Object
73564>>>>>        Set psCaption to C_$CaptionHelp
73565>>>>>        Set psDescription to C_$ToolTipHelp
73566>>>>>        Set psToolTip to C_$DescHelp
73567>>>>>        Set psImage to "ActionHelp.ico"
73568>>>>>        Set psShortcut to "F1"
73569>>>>>        Set psCategory to C_$CategoryHelp
73570>>>>>    End_Procedure
73571>>>>>    
73571>>>>>    Procedure OnExecute Variant vCommandBarControl
73573>>>>>        Send Help of (Focus(Self))
73574>>>>>    End_Procedure
73575>>>>>    
73575>>>>>End_Class
73576>>>>>
73576>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
73577>>>>>    
73577>>>>>    Procedure Construct_Object
73579>>>>>        Forward Send Construct_Object
73581>>>>>        Set psCaption to C_$CaptionAddStatusbar
73582>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
73583>>>>>        Set psDescription to  C_$DescAddStatusbar
73584>>>>>        Set psCategory to C_$CategoryWindow
73585>>>>>    End_Procedure
73586>>>>>    
73586>>>>>    Procedure OnExecute Variant vCommandBarControl
73588>>>>>        Handle hoCommandBars hoClientArea
73588>>>>>        Get CommandBarSystemObject to hoCommandBars
73589>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73590>>>>>        If hoClientArea Begin
73592>>>>>            // the clientarea's parent panel has message
73592>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
73593>>>>>        End
73593>>>>>>
73593>>>>>    End_Procedure
73594>>>>>    
73594>>>>>    Function IsChecked Returns Boolean
73596>>>>>        Boolean bOn
73596>>>>>        Handle hoCommandBars hoClientArea
73596>>>>>        Get CommandBarSystemObject to hoCommandBars
73597>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73598>>>>>        If hoClientArea Begin
73600>>>>>            // the clientarea's parent panel has message
73600>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
73601>>>>>        End
73601>>>>>>
73601>>>>>        Function_Return bOn
73602>>>>>    End_Function
73603>>>>>End_Class
73604>>>>>
73604>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
73605>>>>>    
73605>>>>>    Procedure Construct_Object
73607>>>>>        Forward Send Construct_Object
73609>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
73610>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
73611>>>>>        Set psDescription to C_$DescAutoArrangeIcons
73612>>>>>        Set psCategory to C_$CategoryWindow
73613>>>>>    End_Procedure
73614>>>>>    
73614>>>>>    Procedure OnExecute Variant vCommandBarControl
73616>>>>>        Handle hoCommandBars hoClientArea
73616>>>>>        Get CommandBarSystemObject to hoCommandBars
73617>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73618>>>>>        If hoClientArea Begin
73620>>>>>            // the clientarea's parent panel has message
73620>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
73621>>>>>        End
73621>>>>>>
73621>>>>>    End_Procedure
73622>>>>>    
73622>>>>>    Function IsChecked Returns Boolean
73624>>>>>        Boolean bOn
73624>>>>>        Handle hoCommandBars hoClientArea
73624>>>>>        Get CommandBarSystemObject to hoCommandBars
73625>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73626>>>>>        If hoClientArea Begin
73628>>>>>            // the clientarea's parent panel has message
73628>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
73629>>>>>        End
73629>>>>>>
73629>>>>>        Function_Return bOn
73630>>>>>    End_Function
73631>>>>>End_Class
73632>>>>>
73632>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
73633>>>>>    
73633>>>>>    Procedure Construct_Object
73635>>>>>        Forward Send Construct_Object
73637>>>>>        Set psCaption to C_$CaptionRestoreMenus
73638>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
73639>>>>>        Set psDescription to C_$DescRestoreMenus
73640>>>>>        Set psCategory to C_$CategoryWindow
73641>>>>>    End_Procedure
73642>>>>>    
73642>>>>>    Procedure OnExecute Variant vCommandBarControl
73644>>>>>        Handle hoCommandBars
73644>>>>>        Get CommandBarSystemObject to hoCommandBars
73645>>>>>        Send RestoreLayout of hoCommandBars
73646>>>>>    End_Procedure
73647>>>>>    
73647>>>>>End_Class
73648>>>>>
73648>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
73649>>>>>    
73649>>>>>    Procedure Construct_Object
73651>>>>>        Forward Send Construct_Object
73653>>>>>        Set psCaption to C_$CaptionCascade
73654>>>>>        Set psToolTip to C_$ToolTipCascade
73655>>>>>        Set psDescription to  C_$DescCascade
73656>>>>>        Set psImage to "ActionCascade.ico"
73657>>>>>        Set psCategory to C_$CategoryWindow
73658>>>>>    End_Procedure
73659>>>>>    
73659>>>>>    Procedure OnExecute Variant vCommandBarControl
73661>>>>>        Handle hoCommandBars hoClientArea
73661>>>>>        Get CommandBarSystemObject to hoCommandBars
73662>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73663>>>>>        If hoClientArea Begin
73665>>>>>            Send Cascade_Windows of hoClientArea
73666>>>>>        End
73666>>>>>>
73666>>>>>    End_Procedure
73667>>>>>End_Class
73668>>>>>
73668>>>>>Class cCJTileHorizontally is a cCJMenuItem
73669>>>>>    
73669>>>>>    Procedure Construct_Object
73671>>>>>        Forward Send Construct_Object
73673>>>>>        Set psCaption to C_$CaptionTileHorizontally
73674>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
73675>>>>>        Set psDescription to  C_$DescTileHorizontally
73676>>>>>        Set psImage to "ActionTileHorizontally.ico"
73677>>>>>        Set psCategory to C_$CategoryWindow
73678>>>>>    End_Procedure
73679>>>>>    
73679>>>>>    Procedure OnExecute Variant vCommandBarControl
73681>>>>>        Handle hoCommandBars hoClientArea
73681>>>>>        Get CommandBarSystemObject to hoCommandBars
73682>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73683>>>>>        If hoClientArea Begin
73685>>>>>            Send Tile_Windows_Horizontal of hoClientArea
73686>>>>>        End
73686>>>>>>
73686>>>>>    End_Procedure
73687>>>>>End_Class
73688>>>>>
73688>>>>>Class cCJTileVertically is a cCJMenuItem
73689>>>>>    
73689>>>>>    Procedure Construct_Object
73691>>>>>        Forward Send Construct_Object
73693>>>>>        Set psCaption to C_$CaptionTileVertically
73694>>>>>        Set psToolTip to C_$ToolTipTileVertically
73695>>>>>        Set psDescription to  C_$DescTileVertically
73696>>>>>        Set psImage to "ActionTileVertically.ico"
73697>>>>>        Set psCategory to C_$CategoryWindow
73698>>>>>    End_Procedure
73699>>>>>    
73699>>>>>    Procedure OnExecute Variant vCommandBarControl
73701>>>>>        Handle hoCommandBars hoClientArea
73701>>>>>        Get CommandBarSystemObject to hoCommandBars
73702>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73703>>>>>        If hoClientArea Begin
73705>>>>>            Send Tile_Windows_Vertical of hoClientArea
73706>>>>>        End
73706>>>>>>
73706>>>>>    End_Procedure
73707>>>>>End_Class
73708>>>>>
73708>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
73709>>>>>    
73709>>>>>    Procedure Construct_Object
73711>>>>>        Forward Send Construct_Object
73713>>>>>        Set psCaption to C_$CaptionMinimizeWindows
73714>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
73715>>>>>        Set psDescription to  C_$DescMinimizeWindows
73716>>>>>        Set psCategory to C_$CategoryWindow
73717>>>>>    End_Procedure
73718>>>>>    
73718>>>>>    Procedure OnExecute Variant vCommandBarControl
73720>>>>>        Handle hoCommandBars hoClientArea
73720>>>>>        Get CommandBarSystemObject to hoCommandBars
73721>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73722>>>>>        If hoClientArea Begin
73724>>>>>            // the clientarea's parent panel has message
73724>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
73725>>>>>        End
73725>>>>>>
73725>>>>>    End_Procedure
73726>>>>>End_Class
73727>>>>>
73727>>>>>
73727>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
73728>>>>>    
73728>>>>>    Procedure Construct_Object
73730>>>>>        Forward Send Construct_Object
73732>>>>>        Set psCaption to C_$CaptionRestoreWindows
73733>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
73734>>>>>        Set psDescription to  C_$DescRestoreWindows
73735>>>>>        Set psCategory to C_$CategoryWindow
73736>>>>>    End_Procedure
73737>>>>>    
73737>>>>>    Procedure OnExecute Variant vCommandBarControl
73739>>>>>        Handle hoCommandBars hoClientArea
73739>>>>>        Get CommandBarSystemObject to hoCommandBars
73740>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73741>>>>>        If hoClientArea Begin
73743>>>>>            // the clientarea's parent panel has message
73743>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
73744>>>>>        End
73744>>>>>>
73744>>>>>    End_Procedure
73745>>>>>End_Class
73746>>>>>
73746>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
73747>>>>>    
73747>>>>>    Procedure Construct_Object
73749>>>>>        Forward Send Construct_Object
73751>>>>>        Set psCaption to C_$CaptionArrangeIcons
73752>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
73753>>>>>        Set psDescription to  C_$DescArrangeIcons
73754>>>>>        Set psCategory to C_$CategoryWindow
73755>>>>>    End_Procedure
73756>>>>>    
73756>>>>>    Procedure OnExecute Variant vCommandBarControl
73758>>>>>        Handle hoCommandBars hoClientArea
73758>>>>>        Get CommandBarSystemObject to hoCommandBars
73759>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73760>>>>>        If hoClientArea Begin
73762>>>>>            Send Arrange_Icons of hoClientArea
73763>>>>>        End
73763>>>>>>
73763>>>>>    End_Procedure
73764>>>>>    
73764>>>>>End_Class
73765>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJAboutMenuItem.pkg)
73765>>>>>Use cCJCommandBarSystem.pkg
73765>>>>>Use LanguageText.pkg
73765>>>>>
73765>>>>>// It is expected that if you use this class that you provide an about object that is
73765>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
73765>>>>>// because you may wish to create your own custom about package.
73765>>>>>
73765>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
73766>>>>>
73766>>>>>    Procedure Construct_Object
73768>>>>>        Forward Send Construct_Object
73770>>>>>        Set psCaption to C_$CaptionAbout
73771>>>>>        Set psDescription to C_$ToolTipAbout
73772>>>>>        Set psToolTip to C_$DescAbout
73773>>>>>        Set psImage to "ActionAbout.ico"
73774>>>>>        Set psCategory to C_$CategoryHelp
73775>>>>>    End_Procedure
73776>>>>>    
73776>>>>>    Procedure OnExecute Variant vCommandBarControl
73778>>>>>        Handle hoCommandBars hoClientArea
73778>>>>>        Get CommandBarSystemObject to hoCommandBars
73779>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
73780>>>>>        If hoClientArea Begin
73782>>>>>            Send Activate_About of hoClientArea
73783>>>>>        End
73783>>>>>>
73783>>>>>    End_Procedure
73784>>>>>
73784>>>>>End_Class
73785>>>>>
73785>>>>>
73785>>>Use cCJDeoMenuItemClasses.pkg
73785>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJMDIWindowsMenuItem.pkg)
73785>>>>>Use cCJCommandBarSystem.pkg
73785>>>>>
73785>>>>>Register_Function Client_ID Returns Integer
73785>>>>>
73785>>>>>// only used by cCJMDIWIndowsMenuItem
73785>>>>>Class cCJMDIWindowItem is a cCJMenuItem
73786>>>>>    
73786>>>>>    Procedure Construct_Object
73788>>>>>        Forward Send Construct_Object
73790>>>>>        Property Handle phWindow 0 // object id of view
73791>>>>>        Set pbControlFlagNoMovable to True
73792>>>>>        Set pbActiveUpdate to True
73793>>>>>    End_Procedure
73794>>>>>    
73794>>>>>    Procedure OnExecute Variant vCommandBarControl
73796>>>>>        Handle hWindow
73796>>>>>        Get phWindow to hWindow
73797>>>>>        Send Activate_View of hWindow
73798>>>>>    End_Procedure
73799>>>>>    
73799>>>>>End_Class
73800>>>>>
73800>>>>>
73800>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
73801>>>>>    
73801>>>>>    Procedure Construct_Object
73803>>>>>        Forward Send Construct_Object
73805>>>>>        Property Handle[] phArrayOfWindows
73806>>>>>        Set peControlType to xtpControlPopup
73807>>>>>        Set psCategory to C_$CategoryWindow
73808>>>>>    End_Procedure
73809>>>>>    
73809>>>>>    // This adds MDI windows to the existing menu items.
73809>>>>>    // This removes any existing windows menus and always adds a new set to the end
73809>>>>>    
73809>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
73811>>>>>        Handle  hClientArea hView
73811>>>>>        String  sLabel
73811>>>>>        Integer i iWindows
73811>>>>>        Handle[] hArrayOfWindows
73812>>>>>        Variant vItem
73812>>>>>        
73812>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
73812>>>>>        // also assume that destroying an action removes all menu instances of that action
73812>>>>>        Get phArrayOfWindows to hArrayOfWindows
73813>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
73814>>>>>        For i from 0 to (iWindows-1)
73820>>>>>>
73820>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
73821>>>>>        Loop
73822>>>>>>
73822>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
73823>>>>>        
73823>>>>>        // Add all views to this menu. Create the action and add the item
73823>>>>>        Move 0 to i
73824>>>>>        Get Client_Id to hClientArea // object id of client area
73825>>>>>        If (hClientArea > 0) Begin
73827>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
73828>>>>>            While (hView <> 0)
73832>>>>>                If (Active_State(hView)) Begin
73834>>>>>                    // create the action
73834>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
73835>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
73836>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
73837>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
73838>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
73840>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
73841>>>>>                    End
73841>>>>>>
73841>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
73842>>>>>                    If (i=0) Begin
73844>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
73845>>>>>                    End
73845>>>>>>
73845>>>>>                    // Create a menu item for this action
73845>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
73846>>>>>                    Increment i
73847>>>>>                End
73847>>>>>>
73847>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
73848>>>>>            Loop
73849>>>>>>
73849>>>>>        End
73849>>>>>>
73849>>>>>        
73849>>>>>        Set phArrayOfWindows to hArrayOfWindows
73850>>>>>        
73850>>>>>    End_Procedure
73851>>>>>    
73851>>>>>End_Class
73852>
73852>Object oApplication is a cApplication
73854>End_Object
73855>
73855>Object oToolTipController is a cToolTipController
73857>    Move Self to ghoToolTipController
73858>End_Object
73859>
73859>Use Cursor.pkg
73859>Object oCursor is a CursorShape
73861>End_Object
73862>
73862>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files\DataFlex 23.0\Pkg\oEditContextMenu.pkg)
73862>>>Use cCJStandardMenuItemClasses.pkg
73862>>>
73862>>>Object oEditContextMenu is a cCJContextMenu
73864>>>    
73864>>>    Move Self to Default_Form_Floating_Menu_ID
73865>>>    
73865>>>    Object oUndoMenuItem is a cCJUndoMenuItem
73867>>>    End_Object
73868>>>    
73868>>>    Object oCutMenuItem is a cCJCutMenuItem
73870>>>        Set pbControlBeginGroup to True
73871>>>    End_Object
73872>>>    
73872>>>    Object oCopyMenuItem is a cCJCopyMenuItem
73874>>>    End_Object
73875>>>
73875>>>    Object oPasteMenuItem is a cCJPasteMenuItem
73877>>>    End_Object
73878>>>
73878>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
73880>>>    End_Object
73881>>>
73881>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
73883>>>        Set pbControlBeginGroup to True
73884>>>    End_Object
73885>>>
73885>>>End_Object
73886>>>
73886>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files\DataFlex 23.0\Pkg\oDEOEditContextMenu17.pkg)
73886>>>Use Windows.pkg
73886>>>Use cCJStandardMenuItemClasses.pkg
73886>>>Use cCJDeoMenuItemClasses.pkg
73886>>>
73886>>>
73886>>>Object oDEOEditContextMenu17 is a cCJContextMenu
73888>>>    
73888>>>    Move Self to Default_dbFloating_Menu_ID
73889>>>    
73889>>>    Object oUndoMenuItem is a cCJUndoMenuItem
73891>>>    End_Object
73892>>>    
73892>>>    Object oCutMenuItem is a cCJCutMenuItem
73894>>>        Set pbControlBeginGroup to True
73895>>>    End_Object
73896>>>    
73896>>>    Object oCopyMenuItem is a cCJCopyMenuItem
73898>>>    End_Object
73899>>>
73899>>>    Object oPasteMenuItem is a cCJPasteMenuItem
73901>>>    End_Object
73902>>>
73902>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
73904>>>    End_Object
73905>>>
73905>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
73907>>>        Set pbControlBeginGroup to True
73908>>>    End_Object
73909>>>
73909>>>    Object oPromptMenuItem is a cCJPromptMenuItem
73911>>>        Set pbControlBeginGroup to True
73912>>>    End_Object
73913>>>
73913>>>    Object oFindNextMenu is a cCJFindNextMenuItem
73915>>>        Set pbControlBeginGroup to True
73916>>>    End_Object
73917>>>
73917>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
73919>>>    End_Object
73920>>>
73920>>>    Object oClearMenuItem is a cCJClearMenuItem
73922>>>        Set pbControlBeginGroup to True
73923>>>    End_Object
73924>>>
73924>>>    Object oClearAllMenu is a cCJClearAllMenuItem
73926>>>    End_Object
73927>>>
73927>>>    Object oSaveMenu is a cCJSaveMenuItem
73929>>>    End_Object
73930>>>    
73930>>>    Object oDeleteMenu is a cCJDeleteMenuItem
73932>>>    End_Object
73933>>>
73933>>>    Object oRememberitem is a cCJRememberFieldMenuItem
73935>>>        Set pbControlBeginGroup to True
73936>>>    End_Object
73937>>>
73937>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
73939>>>    End_Object
73940>>>
73940>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
73942>>>    End_Object
73943>>>
73943>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
73945>>>    End_Object
73946>>>
73946>>>End_Object
73947>Use seq_chnl.pkg
73947>
73947>Object oMain is a Panel
73949>    Set Label to "ChatGPT API Sample"
73950>    Set Location to 4 3
73951>    Set Size to 300 450
73952>    
73952>    // Note: Ideally you should get your own API Key: from https://platform.openai.com/account/api-keys
73952>    //
73952>    // Ha!  This key got disabled by OpenAI when they detected I'd uploaded it to GitHub, so it won't
73952>    // work now, hence you will have to get your own!
73952>    
73952>    Property String psOpenAIAPIKey
73954>    
73954>    Procedure SetOpenAIAPIKey
73957>        Integer iChn
73957>        String  sKey
73957>        
73957>        Get Seq_New_Channel to iChn
73958>        Direct_Input channel iChn "C:\Temp\OpenAIAPIKey.txt"
73960>        Read channel iChn sKey
73962>        Close_Input channel iChn
73964>        Send Seq_Release_Channel iChn
73965>        
73965>        Set psOpenAIAPIKey to sKey
73966>    End_Procedure
73967>    Send SetOpenAIAPIKey
73968>    
73968>    Function OAuth2AccessToken Returns String
73971>        Function_Return (psOpenAIAPIKey(Self))
73972>    End_Function
73973>
73973>    Use JsonPath.pkg
Including file: JsonPath.pkg    (C:\Projects\ChatGPTAPI\AppSrc\JsonPath.pkg)
73973>>>//==============================================================================
73973>>>// JsonPath.pkg
73973>>>//==============================================================================
73973>>>//
73973>>>// Just a simple package which uses the cJsonPath class, creates an object of it,
73973>>>// and adds three global functions: JsonObjectAtPath, JsonValueAtPath and 
73973>>>// JsonCountAtPath, calling those of the object.
73973>>>//
73973>>>// Licence (MIT):
73973>>>//
73973>>>// Copyright 2020, Mike Peat, Unicorn InterGlobal Ltd.
73973>>>//
73973>>>// Permission is hereby granted, free of charge, to any person obtaining a copy
73973>>>// of this software and associated documentation files (the "Software"), to deal
73973>>>// in the Software without restriction, including without limitation the rights
73973>>>// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
73973>>>// copies of the Software, and to permit persons to whom the Software is
73973>>>// furnished to do so, subject to the following conditions:
73973>>>//
73973>>>// The above copyright notice and this permission notice shall be included in
73973>>>// all copies or substantial portions of the Software.
73973>>>//
73973>>>// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
73973>>>// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
73973>>>// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
73973>>>// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
73973>>>// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
73973>>>// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
73973>>>// SOFTWARE.
73973>>>//
73973>>>//==============================================================================
73973>>>
73973>>>Use cJsonPath.pkg
Including file: cJsonPath.pkg    (C:\Projects\ChatGPTAPI\AppSrc\cJsonPath.pkg)
73973>>>>>//==============================================================================
73973>>>>>// cJsonPath.pkg
73973>>>>>//
73973>>>>>// A class which will allow you to get either object handles or values or array
73973>>>>>// copunts from JSON objects using their path.
73973>>>>>// 
73973>>>>>// Author:  Mike Peat
73973>>>>>// Date:    06/02/2020
73973>>>>>//
73973>>>>>// Usage:
73973>>>>>//   To return a JSON object at a path:
73973>>>>>//       Get JsonAtPath of oJsonPathObject hoSourceJsonObject, path to hoVar
73973>>>>>//     or:
73973>>>>>//       Move (JsonAtPath(oJsonPathObject, hoSourceJsonObject, path)) to hoVar
73973>>>>>//
73973>>>>>//   To return a value at a path:
73973>>>>>//       Get ValueAtPath of oJsonPathObject hoSourceJsonObject path to sVar
73973>>>>>//     or
73973>>>>>//       Move (ValueAtPath(oJsonPathObject, hoSourceJson, path)) to sVar
73973>>>>>//
73973>>>>>// Path notation:
73973>>>>>//
73973>>>>>//    A string with JSON object names, separated by dots "." and array indices
73973>>>>>//    in square brackets: "foo.bar.baz[0].bill[1][0]"
73973>>>>>//
73973>>>>>// Sample JSON:
73973>>>>>//
73973>>>>>//    {
73973>>>>>//      "foo": {
73973>>>>>//              "bar": {
73973>>>>>//                      "baz": [
73973>>>>>//                              66.123,
73973>>>>>//                              {
73973>>>>>//                                      "jim": "jack"
73973>>>>>//                              },
73973>>>>>//                              false,
73973>>>>>//                              {
73973>>>>>//                                      "bob": 42
73973>>>>>//                              },
73973>>>>>//                              {
73973>>>>>//                                      "kim": "possible"
73973>>>>>//                              },
73973>>>>>//                              [55, 1, 19, {
73973>>>>>//                                      "Mork": [
73973>>>>>//                                              [35, 67, 88, 100, [21, 33, 45, "Tim"]]
73973>>>>>//                                      ]
73973>>>>>//                              }]
73973>>>>>//                      ]
73973>>>>>//              }
73973>>>>>//      }
73973>>>>>//    }
73973>>>>>//
73973>>>>>// Examples:
73973>>>>>//    Move (JsonAtPath(oJPath, hoJson, "foo.bar.baz[5][3].Mork[0][4][3]")) to hoObj
73973>>>>>//
73973>>>>>//    Get ValueAtPath of oJPath hJson "foo.bar.baz[5][3].Mork[0][4][3]" to sVal
73973>>>>>//      (sVal = "Tim")
73973>>>>>//
73973>>>>>// In the first example the JSON object would be returned; if you then performed
73973>>>>>// Move (JsonValue(hoObj)) to sVal you would get the same result as the second
73973>>>>>// example - i.e. "Tim".
73973>>>>>//
73973>>>>>// NOTE: JSON is case-sensitive, so your path-strings must exactly match the
73973>>>>>//       object names ("foo" is *not* "Foo") in the JSON file.
73973>>>>>//
73973>>>>>//==============================================================================
73973>>>>>//
73973>>>>>// Structure
73973>>>>>// =========
73973>>>>>//
73973>>>>>// The core function is JsonAtPath, which returns the JSON member in the passed
73973>>>>>// Json Object at the passed Path, if it is there.
73973>>>>>//
73973>>>>>// The two other public functions - ValueAtPath and CountAtPath - just call
73973>>>>>// JsonAtPath and then work on that to extract the Json value or the Array count
73973>>>>>// of that object respectively.
73973>>>>>//
73973>>>>>// JsonAtPath is supported by the two private functions, ObjectHandle and
73973>>>>>// ArrayHandle, which deal with Json Objects and Array Objects respectively that
73973>>>>>// are encountered in working down the path.  These call each other (or
73973>>>>>// theselves) recursively to deal with elements of the path.
73973>>>>>//
73973>>>>>//==============================================================================
73973>>>>>// Licence (MIT):
73973>>>>>//
73973>>>>>// Copyright 2020, Mike Peat, Unicorn InterGlobal Ltd.
73973>>>>>//
73973>>>>>// Permission is hereby granted, free of charge, to any person obtaining a copy
73973>>>>>// of this software and associated documentation files (the "Software"), to deal
73973>>>>>// in the Software without restriction, including without limitation the rights
73973>>>>>// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
73973>>>>>// copies of the Software, and to permit persons to whom the Software is
73973>>>>>// furnished to do so, subject to the following conditions:
73973>>>>>//
73973>>>>>// The above copyright notice and this permission notice shall be included in
73973>>>>>// all copies or substantial portions of the Software.
73973>>>>>//
73973>>>>>// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
73973>>>>>// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
73973>>>>>// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
73973>>>>>// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
73973>>>>>// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
73973>>>>>// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
73973>>>>>// SOFTWARE.
73973>>>>>//
73973>>>>>//==============================================================================
73973>>>>>// Added CountAtPath function to return the count of elements in an array at the
73973>>>>>// passed path.
73973>>>>>//==============================================================================
73973>>>>>//
73973>>>>>// 2023-03-29  MJP (UIG): Allowed passing a JSON Array instead of a JSON Object.
73973>>>>>//
73973>>>>>//==============================================================================
73973>>>>>//
73973>>>>>// 2023-04-05  MJP (UIG): Changed logic for passing an empty (i.e. "") path.
73973>>>>>//                        Previously this would be an error and always return 0,
73973>>>>>//                        but it turns out that sometimes it is not, so handled
73973>>>>>//                        it better (I think! :0).  Seems to work OK.
73973>>>>>//
73973>>>>>//==============================================================================
73973>>>>>
73973>>>>>Use UI
73973>>>>>Use cJsonObject.pkg
Including file: cJsonObject.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cJsonObject.pkg)
73973>>>>>>>// cJSONObject is defined directly in fmac
73973>>>>>>>// We just define the constants here. They have intentionally not been moved to fmac
73973>>>>>>>
73973>>>>>>>
73973>>>>>>>Enum_List
73973>>>>>>>    Define jpWhitespace_Plain for 0
73973>>>>>>>    Define jpWhitespace_Spaced for 1
73973>>>>>>>    Define jpWhitespace_Pretty for 2
73973>>>>>>>End_Enum_List
73973>>>>>>>
73973>>>>>>>Enum_List
73973>>>>>>>    Define jsonTypeNull
73973>>>>>>>    Define jsonTypeBoolean
73973>>>>>>>    Define jsonTypeDouble
73973>>>>>>>    Define jsonTypeInteger
73973>>>>>>>    Define jsonTypeObject
73973>>>>>>>    Define jsonTypeArray
73973>>>>>>>    Define jsonTypeString
73973>>>>>>>End_Enum_List
73973>>>>>>>
73973>>>>>
73973>>>>>Class cJsonPath is a cObject
73974>>>>>    
73974>>>>>    Function ArrayHandle Handle hoJson String sPath Returns Handle
73976>>>>>        Integer iLSBPos iRSBPos iIndex
73976>>>>>        Handle  hoMemb hoObj
73976>>>>>        
73976>>>>>        If not hoJson ;            Function_Return 0
73979>>>>>            
73979>>>>>        If (sPath = "") Begin
73981>>>>>            
73981>>>>>            If (JsonType(hoJson) = jsonTypeArray) ;                Function_Return hoJson
73984>>>>>                
73984>>>>>            Send Destroy of hoJson
73985>>>>>            Function_Return 0
73986>>>>>        End
73986>>>>>>
73986>>>>>        
73986>>>>>        Move (Pos("[", sPath)) to iLSBPos
73987>>>>>        Move (Pos("]", sPath)) to iRSBPos
73988>>>>>        
73988>>>>>        If (not(iLSBPos) or ;            not(iRSBPos) or ;            (iLSBPos > iRSBPos) or ;            (iLSBPos <> 1)) Begin
73990>>>>>            Send Destroy of hoJson
73991>>>>>            Function_Return 0
73992>>>>>        End
73992>>>>>>
73992>>>>>        
73992>>>>>        Move (Mid(sPath, (iRSBPos - iLSBPos - 1), (iLSBPos + 1))) to iIndex
73993>>>>>        
73993>>>>>        If (MemberCount(hoJson) <= iIndex) Begin
73995>>>>>            Send Destroy of hoJson
73996>>>>>            Function_Return 0
73997>>>>>        End
73997>>>>>>
73997>>>>>        
73997>>>>>        Get MemberByIndex of hoJson iIndex to hoMemb
73998>>>>>
73998>>>>>        If (Length(Trim(sPath)) = iRSBPos) Begin // It ends here
74000>>>>>            Send Destroy of hoJson
74001>>>>>            Function_Return hoMemb
74002>>>>>        End
74002>>>>>>
74002>>>>>
74002>>>>>        Move (Right(sPath, (Length(sPath) - iRSBPos))) to sPath
74003>>>>>        If (Left(sPath, 1) = ".") ;            Move (Replace(".", sPath, "")) to sPath
74006>>>>>        Get ObjectHandle hoMemb sPath to hoObj
74007>>>>>        Send Destroy of hoJson
74008>>>>>        Function_Return hoObj
74009>>>>>    End_Function
74010>>>>>    
74010>>>>>    Function ObjectHandle Handle hoJson String sPath Returns Handle
74012>>>>>        Integer iLSBPos iDotPos iPos
74012>>>>>        String  sMemb
74012>>>>>        Handle  hoMemb hoObj
74012>>>>>
74012>>>>>        If not hoJson ;            Function_Return 0
74015>>>>>        
74015>>>>>        If (sPath = "") Begin
74017>>>>>            
74017>>>>>            If (JsonType(hoJson) = jsonTypeObject) ;                Function_Return hoJson
74020>>>>>                
74020>>>>>            Send Destroy of hoJson
74021>>>>>            Function_Return 0
74022>>>>>        End
74022>>>>>>
74022>>>>>            
74022>>>>>        If (Left(sPath, 1) = "[") ;            Function_Return (ArrayHandle(Self, hoJson, sPath))
74025>>>>>        
74025>>>>>        Move (Pos(".", sPath))      to iDotPos
74026>>>>>        Move (Pos("[", sPath))      to iLSBPos
74027>>>>>        
74027>>>>>        If (iLSBPos and iDotPos) ;            Move (iDotPos min iLSBPos)  to iPos
74030>>>>>        Else If (iDotPos) ;            Move iDotPos                to iPos
74034>>>>>        Else ;            Move iLSBPos                to iPos
74036>>>>>        
74036>>>>>        If not iPos Begin  // We are there!
74038>>>>>            
74038>>>>>            If (HasMember(hoJson, sPath)) Begin
74040>>>>>                Get Member of hoJson sPath to hoMemb
74041>>>>>                Send Destroy of hoJson
74042>>>>>                Function_Return hoMemb
74043>>>>>            End
74043>>>>>>
74043>>>>>            Else Begin
74044>>>>>                Send Destroy of hoJson
74045>>>>>                Function_Return 0
74046>>>>>            End
74046>>>>>>
74046>>>>>        
74046>>>>>        End
74046>>>>>>
74046>>>>>        
74046>>>>>        Move (Left(sPath, (iPos - 1)))    to sMemb
74047>>>>>        
74047>>>>>        If (HasMember(hoJson, sMemb)) Begin
74049>>>>>            Get Member of hoJson sMemb to hoMemb
74050>>>>>            Send Destroy of hoJson
74051>>>>>            Move (Right(sPath, (Length(sPath) - iPos + 1))) to sPath
74052>>>>>            If (Left(sPath, 1) = ".") ;                Move (Replace(".", sPath, "")) to sPath
74055>>>>>            Get ObjectHandle hoMemb sPath to hoObj
74056>>>>>            Function_Return hoObj
74057>>>>>        End
74057>>>>>>
74057>>>>>        
74057>>>>>        Send Destroy of hoJson
74058>>>>>        Function_Return 0
74059>>>>>    End_Function
74060>>>>>    
74060>>>>>    Function JsonAtPath Handle hoJson String sPath Returns Handle
74062>>>>>        Handle  hoObj
74062>>>>>        UChar[] ucaJson
74063>>>>>        Boolean bOK
74063>>>>>        
74063>>>>>        If not hoJson ;            Function_Return 0
74066>>>>>        
74066>>>>>        If ((JsonType(hoJson) = jsonTypeArray) and (MemberCount(hoJson) = 0)) ;            Function_Return 0
74069>>>>>        
74069>>>>>        // Do this to "copy" hoJson to hoObj, so hoJson does not get destroyed
74069>>>>>        // in the process
74069>>>>>        Get StringifyUtf8 of hoJson to ucaJson
74070>>>>>        Get CreateNamed (RefClass(cJsonObject)) "CopyJson" to hoObj
74071>>>>>        Get ParseUtf8 of hoObj ucaJson to bOK
74072>>>>>        If (JsonType(hoObj) = jsonTypeArray) ;            Function_Return (ArrayHandle(Self, hoObj, sPath))
74075>>>>>        Else ;            Function_Return (ObjectHandle(Self, hoObj, sPath))
74077>>>>>    End_Function
74078>>>>>    
74078>>>>>    Function ValueAtPath Handle hoJson String sPath Returns String
74080>>>>>        Handle  hoObj
74080>>>>>        String  sVal
74080>>>>>        Integer iType
74080>>>>>        
74080>>>>>        Get JsonAtPath hoJson sPath to hoObj
74081>>>>>
74081>>>>>        If hoObj Begin
74083>>>>>            Get JsonType of hoObj to iType
74084>>>>>            
74084>>>>>            If ((iType <> jsonTypeObject) and ;                (iType <> jsonTypeArray) and ;                (iType <> jsonTypeNull)) ;                Move (JsonValue(hoObj)) to sVal
74087>>>>>            
74087>>>>>            Send Destroy of hoObj
74088>>>>>        End
74088>>>>>>
74088>>>>>        
74088>>>>>        Function_Return sVal
74089>>>>>    End_Function
74090>>>>>    
74090>>>>>    Function CountAtPath Handle hoJson String sPath Returns Integer
74092>>>>>        Integer iCount
74092>>>>>        
74092>>>>>        Get JsonAtPath hoJson sPath to hoJson
74093>>>>>        
74093>>>>>        If not hoJson ;            Function_Return 0
74096>>>>>        
74096>>>>>        If (JsonType(hoJson) = jsonTypeArray) ;            Get MemberCount of hoJson to iCount
74099>>>>>            
74099>>>>>        Send Destroy of hoJson
74100>>>>>        Function_Return iCount
74101>>>>>    End_Function
74102>>>>>
74102>>>>>End_Class
74103>>>
74103>>>Object oJsonPathObject is a cJsonPath
74105>>>End_Object
74106>>>
74106>>>Function JsonObjectAtPath Global Handle hoJson String sPath Returns Handle
74108>>>    Function_Return (JsonAtPath(oJsonPathObject, hoJson, sPath))
74109>>>End_Function
74110>>>
74110>>>Function JsonValueAtPath Global Handle hoJson String sPath Returns String
74112>>>    Function_Return (ValueAtPath(oJsonPathObject, hoJson, sPath))
74113>>>End_Function
74114>>>
74114>>>Function JsonCountAtPath Global Handle hoJson String sPath Returns Integer
74116>>>    Function_Return (CountAtPath(oJsonPathObject, hoJson, sPath))
74117>>>End_Function
74118>    
74118>    Object oClientArea is a ClientArea
74120>        Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files\DataFlex 23.0\Pkg\StdAbout.pkg)
74120>>>// This provides a quick and simple way to create an about package for a program.
74120>>>// You need to create a message inside you client area called Activate_About.
74120>>>// Within this message you should send the message DoAbout passing needed
74120>>>// string information.
74120>>>//
74120>>>//       Procedure Activate_About
74120>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
74120>>>//       End_Procedure
74120>>>//    where: sTitle =     Name of application. If none provided, uses caption
74120>>>//                        bar title
74120>>>//           sVersion   = Version Line. If none provided, will be blank
74120>>>//           sCopyRight = Copyright Line. If none provided, will be blank
74120>>>//           sAuthor    = Author name, blank if none provided
74120>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
74120>>>//                        is used.
74120>>>// It is expected that you will place this in your own object package. For
74120>>>// example an order about package may look like this:
74120>>>//
74120>>>//   // OrderAbout.pkg
74120>>>//   Use StdAbout.pkg
74120>>>//   Procedure Activate_About
74120>>>//      String sTitle sCopyright sVersion sAuthor
74120>>>//      Move "My Order Entry System" to sTitle
74120>>>//      Move "Version 2.1" to sVersion
74120>>>//      Move "Copyright xxxx, Super Software Inc." to sCopyright
74120>>>//      Move "John Smith"  to sAuthor
74120>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
74120>>>//   end_procedure
74120>>>//   // end of file.
74120>>>
74120>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files\DataFlex 23.0\Pkg\Dfabout.pkg)
74120>>>>>Use LanguageText.pkg
74120>>>>>Use Windows.pkg
74120>>>>>Use DFbitmap.pkg
74120>>>>>Use GlobalFunctionsProcedures.pkg
74120>>>>>Use cTextEdit.pkg
74120>>>>>Use tWinStructs.pkg
74120>>>>>
74120>>>>>Use cli.pkg
74120>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files\DataFlex 23.0\Pkg\DFBTRDRV.PKG)
74120>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
74120>>>>>>>// Notice      : This package contains constants and commands, used to call
74120>>>>>>>//               specific functions in the DFBTRDRV.
74120>>>>>>>Use Ui
74120>>>>>>>//
74120>>>>>>>// Driver Indentification
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>// Driver attributes
74120>>>>>>>//
74120>>>>>>>// Call_Driver functions ID's
74120>>>>>>>//
74120>>>>>>>//
74120>>>>>>>// DFBTRFN_CONVERT_FILE options
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// DFBTRFN_SET_OWNER options
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to create all vars which may be needed
74120>>>>>>>// in other commands.
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to set the owner of a Btrieve file.
74120>>>>>>>// File must have been opened.
74120>>>>>>>// Filenumber needs to be passed.
74120>>>>>>>// To clear set the owner to "".
74120>>>>>>>// Examples:
74120>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
74120>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
74120>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
74120>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
74120>>>>>>>// To clear:
74120>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to parse DFBTR_SET_OWNVER
74120>>>>>>>// options.
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to parse for Callback
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to clear the owner of a Btrieve file.
74120>>>>>>>// File must have been opened.
74120>>>>>>>// Filenumber needs to be passed.
74120>>>>>>>// Examples:
74120>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to add a owner name to the internal list of ownernames
74120>>>>>>>// which will be tries when opening files.
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to remove all owners from the internal list of ownernames
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to set the owner name to be used when opening the DDF files.
74120>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
74120>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
74120>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to change the transaction type.
74120>>>>>>>// Valid types are:
74120>>>>>>>//     DFBTRTT_NONE
74120>>>>>>>//     DFBTRTT_EXCLUSIVE
74120>>>>>>>//     DFBTRTT_CONCURRENT
74120>>>>>>>//
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to get the current transaction type.
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to set explicit_locking
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to get explicit locking
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>//
74120>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
74120>>>>>>>//
74120>>>>>>>
74120>>>>>>>// Purpose: An instance of this class can be used as a broker object to
74120>>>>>>>//          call several Dfbtrdrv releated methods.
74120>>>>>>>
74120>>>>>>>Class cDFBtrDrvHandler is an Array
74121>>>>>>>    
74121>>>>>>>    Procedure Construct_Object Integer iImage
74123>>>>>>>        Forward Send Construct_object iImage
74125>>>>>>>        
74125>>>>>>>        Property String  psDriverID "DFBTRDRV"
74126>>>>>>>    End_Procedure
74127>>>>>>>    
74127>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
74127>>>>>>>    //
74127>>>>>>>    
74127>>>>>>>    Function CKRevision Returns String
74129>>>>>>>        String  sDriverID
74129>>>>>>>        String  sRevision
74129>>>>>>>        String  sVoid
74129>>>>>>>        Integer iRetval
74129>>>>>>>        
74129>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
74129>>>>>>>        // This error would otherwise be raised when we have an older
74129>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
74129>>>>>>>        Send Ignore_error to Error_object_Id 20491
74130>>>>>>>        Get psDriverID to sDriverID
74131>>>>>>>        Move (Repeat(" ", 255)) to sRevision
74132>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
74137>>>>>>>        Send Trap_Error to Error_object_Id 20491
74138>>>>>>>        If (Trim(sRevision) = "") Begin
74140>>>>>>>            // Unable to get the revision. return all zeroes.
74140>>>>>>>            Move "0.0.0.0" to sRevision
74141>>>>>>>        End
74141>>>>>>>>
74141>>>>>>>        Function_Return sRevision
74142>>>>>>>    End_Function
74143>>>>>>>    
74143>>>>>>>    Function CkUsesUri Returns Integer
74145>>>>>>>        String  sDriverID
74145>>>>>>>        String  sVoid1
74145>>>>>>>        String  sVoid2
74145>>>>>>>        Integer iRetval
74145>>>>>>>        
74145>>>>>>>        Get psDriverID to sDriverID
74146>>>>>>>        
74146>>>>>>>        Move 0 to iRetval
74147>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
74147>>>>>>>        // This error would otherwise be raised when we have an older
74147>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
74147>>>>>>>        Send Ignore_error to Error_object_Id 20491
74148>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
74153>>>>>>>        Send Trap_Error to Error_object_Id 20491
74154>>>>>>>        
74154>>>>>>>        Function_Return iRetval
74155>>>>>>>    End_Function
74156>>>>>>>    
74156>>>>>>>    
74156>>>>>>>    
74156>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
74156>>>>>>>    //
74156>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
74156>>>>>>>    //
74156>>>>>>>    
74156>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
74158>>>>>>>        Integer iPartRev
74158>>>>>>>        Integer iCurrentPart
74158>>>>>>>        Integer iSeparatorPos
74158>>>>>>>        
74158>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
74161>>>>>>>        
74161>>>>>>>        Move 0 to iCurrentPart
74162>>>>>>>        Repeat
74162>>>>>>>>
74162>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
74163>>>>>>>            If (iSeparatorPos > 0) Begin
74165>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
74166>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
74167>>>>>>>                Increment iCurrentPart
74168>>>>>>>            End
74168>>>>>>>>
74168>>>>>>>            Else If (sRevision <> "") Begin
74171>>>>>>>                Move sRevision to iPartRev
74172>>>>>>>                Move "" to sRevision
74173>>>>>>>                Increment iCurrentPart
74174>>>>>>>            End
74174>>>>>>>>
74174>>>>>>>            Else ;                Move -1 to iPartRev
74176>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
74178>>>>>>>        
74178>>>>>>>        Function_Return iPartRev
74179>>>>>>>    End_Function
74180>>>>>>>    
74180>>>>>>>    
74180>>>>>>>    
74180>>>>>>>    //
74180>>>>>>>    //  Returns the major revision of the CK
74180>>>>>>>    //
74180>>>>>>>    
74180>>>>>>>    Function CKMajorRevision Returns Integer
74182>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
74183>>>>>>>    End_Function
74184>>>>>>>    
74184>>>>>>>    
74184>>>>>>>    
74184>>>>>>>    //  Returns the minor revision of the CK
74184>>>>>>>    //
74184>>>>>>>    
74184>>>>>>>    Function CKMinorRevision Returns Integer
74186>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
74187>>>>>>>    End_Function
74188>>>>>>>    
74188>>>>>>>    
74188>>>>>>>    //  Returns the release revision of the CK
74188>>>>>>>    //
74188>>>>>>>    
74188>>>>>>>    Function CKReleaseRevision Returns Integer
74190>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
74191>>>>>>>    End_Function
74192>>>>>>>    
74192>>>>>>>    
74192>>>>>>>    //  Returns the major revision of the CK
74192>>>>>>>    //
74192>>>>>>>    
74192>>>>>>>    Function CKBuildRevision Returns Integer
74194>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
74195>>>>>>>    End_Function
74196>>>>>>>    
74196>>>>>>>    
74196>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
74196>>>>>>>    //
74196>>>>>>>    
74196>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
74198>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
74201>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
74204>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
74207>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
74210>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
74213>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
74217>>>>>>>            End
74217>>>>>>>>
74217>>>>>>>        End
74217>>>>>>>>
74217>>>>>>>        
74217>>>>>>>        Function_Return (False)
74218>>>>>>>    End_Function
74219>>>>>>>    
74219>>>>>>>    //   Functions to query the Pervasive.SQL version:
74219>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
74219>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
74219>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
74219>>>>>>>    //
74219>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
74219>>>>>>>    //   in the following format:
74219>>>>>>>    //       <version>.<revision>.<type>
74219>>>>>>>    //   possible values for <type>:
74219>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
74219>>>>>>>    //         server using Workgroup authentication mode
74219>>>>>>>    //       C for client cache engine
74219>>>>>>>    //       D for DOS workstation
74219>>>>>>>    //       N for client Requester
74219>>>>>>>    //       S for NetWare server
74219>>>>>>>    //       T for 32-bit Windows server engine
74219>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
74219>>>>>>>    //
74219>>>>>>>    //   example:
74219>>>>>>>    //       8.50.T
74219>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
74219>>>>>>>    //   32-bits Windows server.
74219>>>>>>>    //
74219>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
74219>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
74219>>>>>>>    //
74219>>>>>>>    //   If the version information is not available or can not be obtained
74219>>>>>>>    //   the functions will return "0.0.0"
74219>>>>>>>    
74219>>>>>>>    //  Returns the version information of the
74219>>>>>>>    //           Pervasive.SQL Client requester.
74219>>>>>>>    
74219>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
74221>>>>>>>        
74221>>>>>>>        String  sDriverID
74221>>>>>>>        String  sVersion
74221>>>>>>>        String  sVoid
74221>>>>>>>        Integer iRetval
74221>>>>>>>        
74221>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
74221>>>>>>>        // This error would otherwise be raised when we have an older
74221>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
74221>>>>>>>        Send Ignore_error to Error_object_Id 20491
74222>>>>>>>        Get psDriverID to sDriverID
74223>>>>>>>        Move (Repeat(" ", 255)) to sVersion
74224>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
74229>>>>>>>        Send Trap_Error to Error_object_Id 20491
74230>>>>>>>        If (Trim(sVersion) = "") Begin
74232>>>>>>>            // Unable to get the revision. return all zeroes.
74232>>>>>>>            Move "0.0.0" to sVersion
74233>>>>>>>        End
74233>>>>>>>>
74233>>>>>>>        Function_Return sVersion
74234>>>>>>>    End_Function
74235>>>>>>>    
74235>>>>>>>    //           Pervasive.SQL Engine
74235>>>>>>>    
74235>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
74237>>>>>>>        
74237>>>>>>>        String  sDriverID
74237>>>>>>>        String  sVersion
74237>>>>>>>        String  sVoid
74237>>>>>>>        Integer iRetval
74237>>>>>>>        
74237>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
74237>>>>>>>        // This error would otherwise be raised when we have an older
74237>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
74237>>>>>>>        Send Ignore_error to Error_object_Id 20491
74238>>>>>>>        Get psDriverID to sDriverID
74239>>>>>>>        Move (Repeat(" ", 255)) to sVersion
74240>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
74245>>>>>>>        Send Trap_Error to Error_object_Id 20491
74246>>>>>>>        If (Trim(sVersion) = "") Begin
74248>>>>>>>            // Unable to get the revision. return all zeroes.
74248>>>>>>>            Move "0.0.0" to sVersion
74249>>>>>>>        End
74249>>>>>>>>
74249>>>>>>>        Function_Return sVersion
74250>>>>>>>    End_Function
74251>>>>>>>    
74251>>>>>>>    //  Returns the version information of the
74251>>>>>>>    //           Pervasive.SQL Server Engine
74251>>>>>>>    
74251>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
74253>>>>>>>        
74253>>>>>>>        String  sDriverID
74253>>>>>>>        String  sVersion
74253>>>>>>>        String  sVoid
74253>>>>>>>        Integer iRetval
74253>>>>>>>        
74253>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
74253>>>>>>>        // This error would otherwise be raised when we have an older
74253>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
74253>>>>>>>        Send Ignore_error to Error_object_Id 20491
74254>>>>>>>        Get psDriverID to sDriverID
74255>>>>>>>        Move (Repeat(" ", 255)) to sVersion
74256>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
74261>>>>>>>        Send Trap_Error to Error_object_Id 20491
74262>>>>>>>        If (Trim(sVersion) = "") Begin
74264>>>>>>>            // Unable to get the revision. return all zeroes.
74264>>>>>>>            Move "0.0.0" to sVersion
74265>>>>>>>        End
74265>>>>>>>>
74265>>>>>>>        Function_Return sVersion
74266>>>>>>>    End_Function
74267>>>>>>>    
74267>>>>>>>End_Class
74268>>>>>>>
74268>>>>>>>
74268>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files\DataFlex 23.0\Pkg\MSSqldrv.pkg)
74268>>>>>>>//     Package that declares MS SQL driver constants and functions.
74268>>>>>>>//     This package can be used by developers who want to add Data Access
74268>>>>>>>//     MS SQL Client specific code to a DataFlex application.
74268>>>>>>>
74268>>>>>>>Use Cli.pkg
74268>>>>>>>Use SQL.pkg
74268>>>>>>>
74268>>>>>>>//   Driver Indentification
74268>>>>>>>
74268>>>>>>>//   Error number constants
74268>>>>>>>
74268>>>>>>>
74268>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
74268>>>>>>>
74268>>>>>>>
74268>>>>>>>
74268>>>>>>>
74268>>>>>>>
74268>>>>>>>
74268>>>>>>>// SQL Server spcific types.
74268>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
74268>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
74268>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
74268>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
74268>>>>>>>
74268>>>>>>>// SQL Server spcific types.
74268>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
74268>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
74268>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
74268>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
74268>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
74268>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
74268>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
74268>>>>>>>
74268>>>>>>>
74268>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
74268>>>>>>>//
74268>>>>>>>//     Setup a constraint for a file.
74268>>>>>>>
74268>>>>>>>
74268>>>>>>>Class cMSSQLHandler is a cCLIHandler
74269>>>>>>>    
74269>>>>>>>    Procedure Construct_Object
74271>>>>>>>        Forward Send Construct_Object
74273>>>>>>>        
74273>>>>>>>        Set psDriverID to MSSQLDRV_ID
74274>>>>>>>    End_Procedure
74275>>>>>>>    
74275>>>>>>>    
74275>>>>>>>    
74275>>>>>>>    //   Extract the list from the out connect string.
74275>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
74277>>>>>>>        String  sItem
74277>>>>>>>        Integer iStart
74277>>>>>>>        Integer iEnd
74277>>>>>>>        
74277>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
74280>>>>>>>        
74280>>>>>>>        Send Delete_Data to hoStore
74281>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
74282>>>>>>>        While (iStart > 0)
74286>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
74287>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
74290>>>>>>>            Else Begin
74291>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
74292>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
74293>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
74296>>>>>>>                
74296>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
74299>>>>>>>                
74299>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
74302>>>>>>>            End
74302>>>>>>>>
74302>>>>>>>        Loop
74303>>>>>>>>
74303>>>>>>>        
74303>>>>>>>        Function_Return (Item_Count(hoStore))
74304>>>>>>>    End_Procedure
74305>>>>>>>    
74305>>>>>>>    
74305>>>>>>>    
74305>>>>>>>    //   Call the driver's browse connect function
74305>>>>>>>    Function BrowseConnect String sInConnStr Returns String
74307>>>>>>>        String  sDriver
74307>>>>>>>        String  sOutConnStr
74307>>>>>>>        Integer iArg
74307>>>>>>>        Integer iRetval
74307>>>>>>>        
74307>>>>>>>        Get psDriverID to sDriver
74308>>>>>>>        If (sDriver <> "") Begin
74310>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
74311>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
74316>>>>>>>        End
74316>>>>>>>>
74316>>>>>>>        
74316>>>>>>>        Function_Return sOutConnStr
74317>>>>>>>    End_Function// BrowseConnect
74318>>>>>>>    
74318>>>>>>>    
74318>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
74320>>>>>>>        String  sDriver
74320>>>>>>>        String  sOutConnStr
74320>>>>>>>        Integer iArg
74320>>>>>>>        Integer iRetval
74320>>>>>>>        
74320>>>>>>>        Move 1 to iArg // Browses only local
74321>>>>>>>        
74321>>>>>>>        Get psDriverID to sDriver
74322>>>>>>>        If (sDriver <> "") Begin
74324>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
74325>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
74330>>>>>>>        End
74330>>>>>>>>
74330>>>>>>>        
74330>>>>>>>        Function_Return sOutConnStr
74331>>>>>>>    End_Function// BrowseConnect
74332>>>>>>>    
74332>>>>>>>    
74332>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
74334>>>>>>>        
74334>>>>>>>        String  sServerList
74334>>>>>>>        Integer iNumServers
74334>>>>>>>        Integer iDriver
74334>>>>>>>        Integer iClientVersion
74334>>>>>>>        String  sDriver
74334>>>>>>>        
74334>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
74335>>>>>>>        
74335>>>>>>>        If (iDriver) Begin
74337>>>>>>>            
74337>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
74340>>>>>>>            
74340>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
74341>>>>>>>            
74341>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
74342>>>>>>>            If (iNetworkLocal = 0) Begin
74344>>>>>>>                Get BrowseConnect sDriver to sServerList
74345>>>>>>>            End
74345>>>>>>>>
74345>>>>>>>            Else Begin
74346>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
74347>>>>>>>            End
74347>>>>>>>>
74347>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
74348>>>>>>>        End
74348>>>>>>>>
74348>>>>>>>        
74348>>>>>>>        Function_Return iNumServers
74349>>>>>>>        
74349>>>>>>>    End_Function
74350>>>>>>>    
74350>>>>>>>    //   Enumerate the available SQL Server database servers
74350>>>>>>>    //   This function will return all SQL Server instances on the network.
74350>>>>>>>    //   This may take a long time.
74350>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
74350>>>>>>>    Function EnumerateServers Returns Integer
74352>>>>>>>        
74352>>>>>>>        Integer iNumServers
74352>>>>>>>        Integer iNetworkLocal
74352>>>>>>>        
74352>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
74353>>>>>>>        
74353>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
74354>>>>>>>        
74354>>>>>>>        Function_Return iNumServers
74355>>>>>>>        
74355>>>>>>>    End_Function
74356>>>>>>>    
74356>>>>>>>    
74356>>>>>>>    //   Enumerate the available SQL Server database servers
74356>>>>>>>    //   This function will return only return SQL Server instance on the local machine
74356>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
74356>>>>>>>    Function EnumerateServersLocal Returns Integer
74358>>>>>>>        
74358>>>>>>>        Integer iNumServers
74358>>>>>>>        Integer iNetworkLocal
74358>>>>>>>        
74358>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
74359>>>>>>>        
74359>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
74360>>>>>>>        
74360>>>>>>>        Function_Return iNumServers
74361>>>>>>>        
74361>>>>>>>    End_Function
74362>>>>>>>    
74362>>>>>>>    
74362>>>>>>>    
74362>>>>>>>    //   Enumerate database in a given server.
74362>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
74364>>>>>>>        Integer hoSQL
74364>>>>>>>        String  sConnect
74364>>>>>>>        String  sDatabase
74364>>>>>>>        Integer hdbc
74364>>>>>>>        Integer hstmt
74364>>>>>>>        Integer iFetchResult
74364>>>>>>>        
74364>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
74367>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
74370>>>>>>>        
74370>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
74373>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
74375>>>>>>>        
74375>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
74377>>>>>>>            Move Current_Object to hoSQL
74378>>>>>>>        End_Object
74379>>>>>>>        
74379>>>>>>>        If (hoSQL <> 0) Begin
74381>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
74382>>>>>>>            If (hdbc <> 0) Begin
74384>>>>>>>                Get SQLOpen of hdbc to hstmt
74385>>>>>>>                If (hstmt <> 0) Begin
74387>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
74387>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
74387>>>>>>>                    //   approach in case meta data might change, the stored procedure will
74387>>>>>>>                    //   stay the same.
74387>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
74388>>>>>>>                    Send SQLCall to hstmt
74389>>>>>>>                    Repeat
74389>>>>>>>>
74389>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
74390>>>>>>>                        If (iFetchResult <> 0) Begin
74392>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
74393>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
74394>>>>>>>                        End
74394>>>>>>>>
74394>>>>>>>                    Until (iFetchResult = 0)
74396>>>>>>>                    
74396>>>>>>>                    Send SQLClose to hstmt
74397>>>>>>>                End
74397>>>>>>>>
74397>>>>>>>                Send SQLDisconnect to hdbc
74398>>>>>>>            End
74398>>>>>>>>
74398>>>>>>>        End
74398>>>>>>>>
74398>>>>>>>        Send Destroy_Object to hoSQL
74399>>>>>>>        
74399>>>>>>>        Function_Return (Item_Count(Current_Object))
74400>>>>>>>    End_Function
74401>>>>>>>    
74401>>>>>>>    
74401>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
74403>>>>>>>        
74403>>>>>>>        String  sSqlServerClientVersionName
74403>>>>>>>        
74403>>>>>>>        
74403>>>>>>>        Case Begin
74403>>>>>>>
74403>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
74405>>>>>>>                Move SQLSERVER2019CLIENTNAME to sSqlServerClientVersionName
74406>>>>>>>                Case Break
74407>>>>>>>            
74407>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
74410>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
74411>>>>>>>                Case Break
74412>>>>>>>                
74412>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
74415>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
74416>>>>>>>                Case Break
74417>>>>>>>            
74417>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
74420>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
74421>>>>>>>                Case Break
74422>>>>>>>            
74422>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
74425>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
74426>>>>>>>                Case Break
74427>>>>>>>            
74427>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
74430>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
74431>>>>>>>                Case Break
74432>>>>>>>            
74432>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
74435>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
74436>>>>>>>                Case Break
74437>>>>>>>            
74437>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
74440>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
74441>>>>>>>                Case Break
74442>>>>>>>            
74442>>>>>>>            Case Else
74442>>>>>>>                Move (SFormat("%1 (version %2) ",SQLSERVERUNKNOWNCLIENTNAME,iClientVersion)) to sSqlServerClientVersionName
74443>>>>>>>                
74443>>>>>>>        Case End
74443>>>>>>>        
74443>>>>>>>        
74443>>>>>>>        Function_Return sSqlServerClientVersionName
74444>>>>>>>        
74444>>>>>>>    End_Function
74445>>>>>>>
74445>>>>>>>
74445>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
74447>>>>>>>        
74447>>>>>>>        String  sSqlServerClientDriverName
74447>>>>>>>        
74447>>>>>>>        Case Begin
74447>>>>>>>
74447>>>>>>>            Case (iClientVersion = SQLSERVER2019CLIENT)
74449>>>>>>>                Move SQLSERVER2019DRVRSTR to sSqlServerClientDriverName
74450>>>>>>>                Case Break
74451>>>>>>>
74451>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
74454>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
74455>>>>>>>                Case Break
74456>>>>>>>                
74456>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
74459>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
74460>>>>>>>                Case Break
74461>>>>>>>            
74461>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
74464>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
74465>>>>>>>                Case Break
74466>>>>>>>            
74466>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
74469>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
74470>>>>>>>                Case Break
74471>>>>>>>            
74471>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
74474>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
74475>>>>>>>                Case Break
74476>>>>>>>            
74476>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
74479>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
74480>>>>>>>                Case Break
74481>>>>>>>            
74481>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
74484>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
74485>>>>>>>                Case Break
74486>>>>>>>            
74486>>>>>>>            Case Else
74486>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
74487>>>>>>>                
74487>>>>>>>        Case End
74487>>>>>>>        
74487>>>>>>>        
74487>>>>>>>        Function_Return sSqlServerClientDriverName
74488>>>>>>>        
74488>>>>>>>    End_Function
74489>>>>>>>    
74489>>>>>>>    
74489>>>>>>>End_Class
74490>>>>>>>
74490>>>>>>>
74490>>>>>
74490>>>>>Register_Function phoWorkspace Returns Handle
74490>>>>>Register_Function Help_filename Returns String
74490>>>>>Register_Function GetHelpFile Returns String
74490>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
74490>>>>>
74490>>>>>// Do not call directly, use the wrapper function instead
74490>>>>>External_Function WNetGetUserW "WNetGetUserW" MPR.DLL ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
74491>>>>>
74491>>>>>// Wrapper Function WNetGetUser
74491>>>>>Function WNetGetUser Global ;    Pointer lpName ;    Pointer lpUser_Name ;    Pointer lpLength ;    Returns DWord
74493>>>>>    
74493>>>>>    DWord   dwResult     
74493>>>>>    UWide   uwName uwUserName
74493>>>>>    UWide   uwName uwUserName
74493>>>>>        
74493>>>>>    Send StringToWide lpName (&uwName)
74494>>>>>    
74494>>>>>    Send WideSetBuffer lpUser_Name lpLength (&uwUserName)    
74495>>>>>    
74495>>>>>    Move (WNetGetUserW (uwName.lpUText, uwUserName.lpUText, lpLength)) to dwResult
74496>>>>>    
74496>>>>>    Send WideToString (&uwUserName) lpUser_Name
74497>>>>>    
74497>>>>>    Function_Return dwResult
74498>>>>>End_Function
74499>>>>>
74499>>>>>//    This function reads the current username Of windows and returns that
74499>>>>>//    name or an text unknown user
74499>>>>>Function Network_User_Name for cDesktop Returns String
74501>>>>>    WString wName
74501>>>>>    Integer iRetval iLength
74501>>>>>    
74501>>>>>    Move 0 to iLength
74502>>>>>    Move (WNetGetUserW (0, 0, AddressOf (iLength))) to iRetval
74503>>>>>    Move (ZeroString(iLength)) to wName
74504>>>>>    Move (WNetGetUserW (0, AddressOf (wName), AddressOf (iLength))) to iRetval
74505>>>>>    
74505>>>>>    If (iRetval = NO_ERROR) Begin
74507>>>>>        Function_Return (CString (wName))
74508>>>>>    End
74508>>>>>>
74508>>>>>    
74508>>>>>    Function_Return "User Unknown"
74509>>>>>End_Function
74510>>>>>
74510>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
74511>>>>>
74511>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
74512>>>>>
74512>>>>>Class SysinfoDisplay is a cTextEdit
74513>>>>>    Procedure Construct_Object
74515>>>>>        Forward Send Construct_Object
74517>>>>>        
74517>>>>>        Set Location to 6 6
74518>>>>>        Set Size to 110 255
74519>>>>>        Set Read_Only_State to True
74520>>>>>        Set pbWrap to False
74521>>>>>    End_Procedure
74522>>>>>    
74522>>>>>    //    This method will show the name Of the current directory in the system
74522>>>>>    //    information box
74522>>>>>    Procedure Show_Current_Directory
74524>>>>>        String sDir
74524>>>>>        
74524>>>>>        Get_Current_Directory to sDir
74525>>>>>        
74525>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
74526>>>>>    End_Procedure
74527>>>>>    
74527>>>>>    Procedure Show_Windows_Directory
74529>>>>>        String sWindir
74529>>>>>        
74529>>>>>        Get_Windows_Directory to sWindir
74530>>>>>        
74530>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
74531>>>>>    End_Procedure
74532>>>>>    
74532>>>>>    Procedure Show_Current_User
74534>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
74535>>>>>    End_Procedure
74536>>>>>    
74536>>>>>    Procedure Show_Number_Format
74538>>>>>        Integer iFormat
74538>>>>>        String sFormatText
74538>>>>>        
74538>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
74541>>>>>        Move (Character (iFormat)) to sFormatText
74542>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
74543>>>>>        
74543>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
74546>>>>>        Move (Character (iFormat)) to sFormatText
74547>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
74548>>>>>    End_Procedure
74549>>>>>    
74549>>>>>    Procedure Show_Filelist_Name
74551>>>>>        String sFilename
74551>>>>>        
74551>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
74554>>>>>        
74554>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
74555>>>>>        Send AppendTextLn ""
74556>>>>>    End_Procedure
74557>>>>>    
74557>>>>>    Procedure Show_Lock_Delay
74559>>>>>        Integer iLockdelay
74559>>>>>        
74559>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
74562>>>>>        
74562>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
74563>>>>>    End_Procedure
74564>>>>>    
74564>>>>>    Procedure Show_Lock_Timeout
74566>>>>>        Integer iLockTimeout
74566>>>>>        
74566>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
74569>>>>>        
74569>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
74570>>>>>    End_Procedure
74571>>>>>    
74571>>>>>    Procedure Show_Screen_Size
74573>>>>>        Integer iYscreensize iXscreensize
74573>>>>>        
74573>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) to iXscreensize
74574>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) to iYscreensize
74575>>>>>        
74575>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
74576>>>>>    End_Procedure
74577>>>>>    
74577>>>>>    Procedure Show_Page_Size
74579>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
74580>>>>>    End_Procedure
74581>>>>>    
74581>>>>>    Procedure Show_Date
74583>>>>>        Date dToday
74583>>>>>        
74583>>>>>        Move (CurrentDateTime()) to  dToday
74584>>>>>        
74584>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
74585>>>>>    End_Procedure
74586>>>>>    
74586>>>>>    Procedure Show_Date_Format
74588>>>>>        Integer iDateFormat
74588>>>>>        String sDateFormat
74588>>>>>        
74588>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
74591>>>>>        Case Begin
74591>>>>>            Case (iDateFormat = DF_DATE_USA)
74593>>>>>                Move C_$USA to sDateFormat
74594>>>>>                Case Break
74595>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
74598>>>>>                Move C_$European to sDateFormat
74599>>>>>                Case Break
74600>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
74603>>>>>                Move C_$Military to sDateFormat
74604>>>>>                Case Break
74605>>>>>            Case Else
74605>>>>>                Move C_$UnknownDateType to sDateFormat
74606>>>>>                Case Break
74607>>>>>        Case End
74607>>>>>        
74607>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
74608>>>>>    End_Procedure
74609>>>>>    
74609>>>>>    Procedure Show_Systemresources
74611>>>>>        tWinMemoryStatusEx MemoryStatusInfo
74611>>>>>        tWinMemoryStatusEx MemoryStatusInfo
74611>>>>>        Integer iRetval
74611>>>>>        
74611>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
74612>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
74613>>>>>        If (iRetval = 0) Begin
74615>>>>>            Move (ShowLastError ()) to iRetval
74616>>>>>        End
74616>>>>>>
74616>>>>>        
74616>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
74617>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
74618>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Integer ( Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0)))
74619>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Integer ( Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0)))
74620>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Integer ( Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0)))
74621>>>>>    End_Procedure
74622>>>>>    
74622>>>>>    Procedure Show_Registration
74624>>>>>        String sRegName
74624>>>>>        Integer iSN iMaxUsers
74624>>>>>        
74624>>>>>        Registration sRegName iSN
74625>>>>>>
74625>>>>>        
74625>>>>>        Get_Licensed_Max_Users to iMaxUsers
74626>>>>>        
74626>>>>>        Send AppendTextLn ""
74627>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
74628>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
74629>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
74630>>>>>    End_Procedure
74631>>>>>    
74631>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
74631>>>>>    // To the workspace object passing the an object and message To send back
74631>>>>>    // To this object. It is expected that the workspace object will send this
74631>>>>>    // message for every line Of information it wants displayed (passing the
74631>>>>>    // information To be displayed
74631>>>>>    Register_Procedure EnumerateWorkspaceData Handle hObjId Handle hmMessId
74631>>>>>    
74631>>>>>    Procedure Show_ServicePack
74633>>>>>        String sKey sVersionDescription sVersion
74633>>>>>        Handle hoRegistry
74633>>>>>        Boolean bExists bOpened
74633>>>>>        
74633>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
74634>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
74635>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
74636>>>>>        
74636>>>>>        Move C_DFVersionRegistryRoot to sKey
74637>>>>>        Get KeyExists of hoRegistry sKey to bExists
74638>>>>>        If (bExists) Begin
74640>>>>>            Get OpenKey of hoRegistry sKey to bOpened
74641>>>>>            If (bOpened) Begin
74643>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
74644>>>>>                If (bExists) Begin
74646>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
74647>>>>>                End
74647>>>>>>
74647>>>>>                
74647>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
74648>>>>>                If (bExists) Begin
74650>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
74651>>>>>                End
74651>>>>>>
74651>>>>>                Send CloseKey of hoRegistry
74652>>>>>            End
74652>>>>>>
74652>>>>>        End
74652>>>>>>
74652>>>>>        Send Destroy of hoRegistry
74653>>>>>        
74653>>>>>        If (sVersionDescription <> "") Begin
74655>>>>>            Send AppendTextLn (sVersionDescription * "-" * sVersion)
74656>>>>>            Send AppendTextLn ""
74657>>>>>        End
74657>>>>>>
74657>>>>>    End_Procedure
74658>>>>>    
74658>>>>>    
74658>>>>>    Procedure Show_WorkspaceInformation
74660>>>>>        Integer hoWorkspace
74660>>>>>        
74660>>>>>        If (ghoApplication <> 0) Begin
74662>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
74663>>>>>            If (hoWorkspace <> 0) Begin
74665>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
74666>>>>>                Send AppendTextLn ""
74667>>>>>            End
74667>>>>>>
74667>>>>>        End
74667>>>>>>
74667>>>>>    End_Procedure
74668>>>>>    
74668>>>>>    // If connection ids are used, we will send the message EnumerateConnections
74668>>>>>    // to the connection manager object passing the an object and message to send
74668>>>>>    // back to this object. It is expected that the connection manager object will
74668>>>>>    // send this message for every line Of information it wants displayed (passing
74668>>>>>    // the information To be displayed
74668>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
74668>>>>>    
74668>>>>>    Procedure Show_ConnectionIdInformation
74670>>>>>        If (ghoConnection > 0) Begin
74672>>>>>            Send AppendTextLn ""
74673>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
74674>>>>>        End
74674>>>>>>
74674>>>>>    End_Procedure
74675>>>>>    
74675>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
74677>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
74678>>>>>    End_Function
74679>>>>>    
74679>>>>>    Procedure Show_Versions
74681>>>>>        Integer iVersion iRevision iBuild
74681>>>>>        
74681>>>>>        Version_Information iVersion iRevision iBuild
74683>>>>>        
74683>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
74684>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
74685>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
74686>>>>>    End_Procedure
74687>>>>>    
74687>>>>>    Procedure Show_Platform
74689>>>>>        Send AppendTextLn (SFormat (C_$Platform,"64-bit"))
74690>>>>>    End_Procedure
74691>>>>>    
74691>>>>>    Function CKRevisionNumber String sDriverID Returns String
74693>>>>>        Handle hoCLIHandler
74693>>>>>        Handle hoDFBtrDrvHandler
74693>>>>>        String sCKRevision
74693>>>>>        
74693>>>>>        
74693>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
74695>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
74696>>>>>            Set psDriverID of hoCLIHandler to sDriverID
74697>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
74698>>>>>            Send Destroy of hoCLIHandler
74699>>>>>        End
74699>>>>>>
74699>>>>>        Else Begin
74700>>>>>            If (sDriverID = "DFBTRDRV") Begin
74702>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
74703>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
74704>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
74705>>>>>                Send Destroy of hoDFBtrDrvHandler
74706>>>>>            End
74706>>>>>>
74706>>>>>        End
74706>>>>>>
74706>>>>>        
74706>>>>>        Function_Return sCKRevision
74707>>>>>    End_Function
74708>>>>>    
74708>>>>>    
74708>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
74710>>>>>        
74710>>>>>        If (sDriverID = "DATAFLEX") Begin
74712>>>>>            Function_Return False
74713>>>>>        End
74713>>>>>>
74713>>>>>        
74713>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
74714>>>>>    End_Function
74715>>>>>    
74715>>>>>    
74715>>>>>    Procedure Show_Drivers
74717>>>>>        String sCurrentDriver sRevNumber
74717>>>>>        String sLoadedDrivers sClientDriver
74717>>>>>        Integer iNumberOfDrivers iCount iClientVersion iMSSQLIndex
74717>>>>>        Boolean bOK
74717>>>>>        Handle hoMsqlDrv
74717>>>>>        
74717>>>>>        Move "" to sLoadedDrivers
74718>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
74721>>>>>        For iCount from 1 to iNumberOfDrivers
74727>>>>>>
74727>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
74730>>>>>            If (sLoadedDrivers <> "") Begin
74732>>>>>                Move (Append (sLoadedDrivers, ", ")) to sLoadedDrivers
74733>>>>>            End
74733>>>>>>
74733>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
74734>>>>>            If (bOK) Begin
74736>>>>>                If (sCurrentDriver = "MSSQLDRV") Begin
74738>>>>>                    Move iCount to iMSSQLIndex
74739>>>>>                End
74739>>>>>>
74739>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
74740>>>>>                // if mssqldrv, show the client number
74740>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
74741>>>>>            End
74741>>>>>>
74741>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) to sLoadedDrivers
74742>>>>>        Loop
74743>>>>>>
74743>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
74744>>>>>        If (iMSSQLIndex>0) Begin
74746>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iMSSQLIndex to iClientVersion
74749>>>>>            Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
74750>>>>>            Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
74751>>>>>            Send Destroy of hoMsqlDrv
74752>>>>>            Send AppendTextLn (SFormat("MSSQLDRV Client Version: %1", sClientDriver))
74753>>>>>        End
74753>>>>>>
74753>>>>>    End_Procedure
74754>>>>>    
74754>>>>>    Procedure Show_HelpFile
74756>>>>>        String sHelpFile
74756>>>>>        Integer eHelpType
74756>>>>>        
74756>>>>>        If (ghoApplication <> 0) Begin
74758>>>>>            Get peHelpType of ghoApplication to eHelpType
74759>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
74761>>>>>                Get GetHelpFile of ghoHtmlHelp to sHelpFile
74762>>>>>            End
74762>>>>>>
74762>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
74765>>>>>                Get Help_filename of Help_object_id to sHelpFile
74766>>>>>            End
74766>>>>>>
74766>>>>>            Else Begin
74767>>>>>                Move C_$ThereIsNoHelpfileDefined to sHelpFile
74768>>>>>            End
74768>>>>>>
74768>>>>>            
74768>>>>>            Send AppendTextLn ""
74769>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
74770>>>>>        End
74770>>>>>>
74770>>>>>    End_Procedure
74771>>>>>    
74771>>>>>    Procedure Show_EnterAsTab
74773>>>>>        Boolean bEnterKeyAsTabKey
74773>>>>>        String sText
74773>>>>>        
74773>>>>>        If (ghoApplication <> 0) Begin
74775>>>>>            Get pbEnterKeyAsTabKey of ghoApplication to bEnterKeyAsTabKey
74776>>>>>            If (bEnterKeyAsTabKey) Begin
74778>>>>>                Move "True" to sText
74779>>>>>            End
74779>>>>>>
74779>>>>>            Else Begin
74780>>>>>                Move "False" to sText
74781>>>>>            End
74781>>>>>>
74781>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
74782>>>>>        End
74782>>>>>>
74782>>>>>    End_Procedure
74783>>>>>    
74783>>>>>    //    During activation we will remove the old information and add the newly
74783>>>>>    //    found systeminformation
74783>>>>>    Procedure Add_Focus Integer hoRoot
74785>>>>>        Forward Send Add_Focus hoRoot
74787>>>>>        
74787>>>>>        Send Delete_Data
74788>>>>>        
74788>>>>>        Set Changed_State to False
74789>>>>>        Set Read_Only_State to True
74790>>>>>        
74790>>>>>        Send Show_ServicePack
74791>>>>>        Send Show_Versions
74792>>>>>        Send Show_Platform
74793>>>>>        Send Show_Drivers
74794>>>>>        If (ghoConnection <> 0) Begin
74796>>>>>            Send Show_ConnectionIdInformation
74797>>>>>        End
74797>>>>>>
74797>>>>>        Send Show_HelpFile
74798>>>>>        Send Show_Current_Directory
74799>>>>>        Send Show_Filelist_Name
74800>>>>>        If (ghoApplication <> 0) Begin
74802>>>>>            Send Show_WorkSpaceInformation // added To show WS info
74803>>>>>        End
74803>>>>>>
74803>>>>>        Send Show_Current_User
74804>>>>>        Send Show_Windows_Directory
74805>>>>>        Send Show_Screen_Size
74806>>>>>        Send Show_Page_Size
74807>>>>>        Send Show_EnterAsTab
74808>>>>>        Send Show_Number_Format
74809>>>>>        Send Show_Date_Format
74810>>>>>        Send Show_Lock_Delay
74811>>>>>        Send Show_Lock_Timeout
74812>>>>>        Send Show_Date
74813>>>>>        Send Show_Systemresources
74814>>>>>        Send Show_Registration
74815>>>>>        Send Beginning_of_Data
74816>>>>>        
74816>>>>>        Set Icon to 'default.ico'
74817>>>>>    End_Procedure
74818>>>>>End_Class
74819>>>>>
74819>>>>>Class SysInfoDialog is a ModalPanel
74820>>>>>    Procedure Construct_Object
74822>>>>>        Forward Send Construct_Object
74824>>>>>        
74824>>>>>        Set Label to C_$SystemInformation
74825>>>>>        Set Size to 140 267
74826>>>>>        Set piMinSize to 140 267
74827>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
74828>>>>>        Set Border_Style to Border_Thick
74829>>>>>        
74829>>>>>        Object oSysinfoDisplay is a SysInfoDisplay
74831>>>>>            Set peAnchors to anAll
74832>>>>>        End_Object
74833>>>>>        
74833>>>>>        Object oCloseButton is a Button
74835>>>>>            Set Label to C_$Close
74836>>>>>            Set Location to 120 210
74837>>>>>            Set Message 0 to (Refproc (Close_Panel))
74838>>>>>            Set Default_State to True
74839>>>>>            Set peAnchors to anBottomRight
74840>>>>>        End_Object
74841>>>>>        
74841>>>>>        On_Key kCancel Send Close_Panel
74842>>>>>    End_Procedure
74843>>>>>End_Class
74844>>>>>
74844>>>>>Class AboutDialog is a ModalPanel
74845>>>>>    Procedure Construct_Object
74847>>>>>        String sVdfRootDir
74847>>>>>        
74847>>>>>        Forward Send Construct_Object
74849>>>>>        
74849>>>>>        Set Label to C_$About
74850>>>>>        Set Size to 89 282
74851>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
74852>>>>>        
74852>>>>>        Object oSysInfoDialog is a SysInfoDialog
74854>>>>>        End_Object
74855>>>>>        
74855>>>>>        Object oBox is a Container3d
74857>>>>>            Set Border_Style to Border_StaticEdge
74858>>>>>            Set Size to 63 272
74859>>>>>            Set Location to 4 5
74860>>>>>            
74860>>>>>            Object oAboutGraphic is a BitmapContainer
74862>>>>>                Set Border_Style to Border_None
74863>>>>>                Set Bitmap_Style to Bitmap_Center
74864>>>>>                Set Size to 48 48
74865>>>>>                Set Location to 7 2
74866>>>>>            End_Object
74867>>>>>            
74867>>>>>            Object oProductName is a TextBox
74869>>>>>                Set Label to C_$ProductName
74870>>>>>                Set Size to 10 45
74871>>>>>                Set Location to 8 53
74872>>>>>            End_Object
74873>>>>>            
74873>>>>>            Object oVersion is a TextBox
74875>>>>>                Set Label to C_$Version
74876>>>>>                Set Size to 10 25
74877>>>>>                Set Location to 21 53
74878>>>>>            End_Object
74879>>>>>            
74879>>>>>            Object oCopyright is a TextBox
74881>>>>>                Set Label to C_$Copyright
74882>>>>>                Set Size to 10 31
74883>>>>>                Set Location to 34 53
74884>>>>>            End_Object
74885>>>>>            
74885>>>>>            Object oAuthor is a TextBox
74887>>>>>                Set Label to C_$Author
74888>>>>>                Set Size to 10 22
74889>>>>>                Set Location to 46 53
74890>>>>>            End_Object
74891>>>>>        End_Object
74892>>>>>        
74892>>>>>        Object oOKButton is a Button
74894>>>>>            On_Item C_$OK Send Close_Panel
74895>>>>>            Set Size to 14 50
74896>>>>>            Set Location to 71 227
74897>>>>>        End_Object
74898>>>>>        
74898>>>>>        Object oSysInfoButton is a Button
74900>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
74901>>>>>            Set Size to 14 50
74902>>>>>            Set Location to 71 171
74903>>>>>        End_Object
74904>>>>>        
74904>>>>>        On_Key Kcancel Send KeyAction of oOKButton
74905>>>>>        
74905>>>>>        Set Logo to "DacAbout.bmp"  // square bitmaps Of 42x42 work best
74906>>>>>    End_Procedure
74907>>>>>    
74907>>>>>    Procedure Set ProductName String sProductName
74909>>>>>        Set Label of oProductName to sProductName
74910>>>>>    End_Procedure
74911>>>>>    
74911>>>>>    Procedure Set Version String sVersion
74913>>>>>        Set Label of oVersion to sVersion
74914>>>>>    End_Procedure
74915>>>>>    
74915>>>>>    Procedure Set Copyright String sCopyright
74917>>>>>        Set Label of oCopyright to sCopyright
74918>>>>>    End_Procedure
74919>>>>>    
74919>>>>>    Procedure Set Author String sAuthor
74921>>>>>        Set Label of oAuthor to sAuthor
74922>>>>>    End_Procedure
74923>>>>>    
74923>>>>>    Procedure Set Logo String sLogo
74925>>>>>        // square bitmaps Of 42x42 work best
74925>>>>>        Set Bitmap of oAboutGraphic to sLogo
74926>>>>>    End_Procedure
74927>>>>>    
74927>>>>>    Procedure Show_Sysinfo
74929>>>>>        Send Popup_Modal of oSysinfoDialog
74930>>>>>    End_Procedure
74931>>>>>    
74931>>>>>    Procedure End_Construct_Object
74933>>>>>        Handle hoVersionInfo
74933>>>>>        Boolean bIncluded
74933>>>>>        Integer iMajor iMinor iRelease iBuild
74933>>>>>        String sLabel
74933>>>>>        
74933>>>>>        Get Label of oVersion to sLabel
74934>>>>>        If (sLabel = C_$VERSION) Begin
74936>>>>>            // set it To the version info Of the program, if available
74936>>>>>            If (ghoApplication <> 0) Begin
74938>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
74939>>>>>                If (hoVersionInfo <> 0) Begin
74941>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
74942>>>>>                    If (bIncluded) Begin
74944>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
74945>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
74946>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
74947>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
74948>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
74949>>>>>                        Set Version to sLabel
74950>>>>>                    End
74950>>>>>>
74950>>>>>                End
74950>>>>>>
74950>>>>>            End
74950>>>>>>
74950>>>>>        End
74950>>>>>>
74950>>>>>        
74950>>>>>        Forward Send End_Construct_Object
74952>>>>>    End_Procedure
74953>>>>>End_Class
74954>>>
74954>>>//  This is the default message. It is expected that you will
74954>>>//  create your own message to override this
74954>>>Procedure Activate_About
74957>>>    Send DoAbout "" "" "" "" ""
74958>>>End_Procedure
74959>>>
74959>>>//  It is expected that you will send this message (most
74959>>>//  likely from Activate_About. This creates an about object, activates it
74959>>>//  and destroys it when done. It is not exepected that you will augment this.
74959>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap
74962>>>    Integer hoObj hoMain
74962>>>    
74962>>>    // create object
74962>>>    Object About is an AboutDialog
74964>>>        // if no title passed use the label of the main panel
74964>>>        // (if a main panel exists).
74964>>>        If (sTitle = "") Begin
74966>>>            Get Main_Window of desktop to hoMain
74967>>>            If hoMain ;                Get Label of hoMain to sTitle
74970>>>        End
74970>>>>
74970>>>        Set productname to sTitle
74971>>>        Set version     to sVersion
74972>>>        Set copyright   to sCopyRight
74973>>>        Set author      to sAuthor
74974>>>        If (sBitmap <> '') ;            Set logo to sBitMap // square bitmaps of 42x42 work best
74977>>>        Move Self to hoObj // object Id
74978>>>    End_Object
74979>>>    Send Popup   of hoObj    // popup the about object
74980>>>    Send Destroy of hoObj // when done, it will be destroyed
74981>>>End_Procedure
74982>>>
74982>        Use ChatGPTTest.vw
Including file: ChatGPTTest.vw    (C:\Projects\ChatGPTAPI\AppSrc\ChatGPTTest.vw)
74982>>>Use Windows.pkg
74982>>>Use DFClient.pkg
74982>>>Use cTextEdit.pkg
74982>>>Use cJsonObject.pkg
74982>>>Use cCJGrid.pkg
74982>>>Use cCJGridColumnRowIndicator.pkg
Including file: cCJGridColumnRowIndicator.pkg    (C:\Program Files\DataFlex 23.0\Pkg\cCJGridColumnRowIndicator.pkg)
74982>>>>>Use cCJGridColumn.pkg
74982>>>>>
74982>>>>>Class cCJGridColumnRowIndicator is a cCJGridColumn
74983>>>>>    
74983>>>>>    Procedure Construct_Object
74985>>>>>        Forward Send Construct_Object
74987>>>>>        
74987>>>>>        Property Integer piImage 0
74988>>>>>        
74988>>>>>        Set psCaption to ""
74989>>>>>        Set piWidth to 20
74990>>>>>        Set pbResizable to False
74991>>>>>        Set pbEditable to False
74992>>>>>        Set pbFocusable to False
74993>>>>>        Set pbAllowDrag to False
74994>>>>>        Set psToolTip to "Row Indicator"
74995>>>>>    End_Procedure
74996>>>>>    
74996>>>>>    Procedure OnCreateColumn
74998>>>>>        Integer iImage
74998>>>>>        Delegate Get AddImage "GridColumnRowIndicator.bmp" 0 to iImage
75000>>>>>        Set piImage to iImage
75001>>>>>    End_Procedure
75002>>>>>    
75002>>>>>    Procedure OnSetDisplayMetrics Handle hoGridItemMetrics Integer iRow String ByRef sValue
75004>>>>>        Integer iImage iFocusedRow
75004>>>>>        Handle hoDataSource
75004>>>>>        
75004>>>>>        Get phoDataSource to hoDataSource
75005>>>>>        Get SelectedRow of hoDataSource to iFocusedRow
75006>>>>>        Move -1 to iImage
75007>>>>>        If (iRow = iFocusedRow) Begin
75009>>>>>            Get piImage to iImage
75010>>>>>            Set ComItemIcon of hoGridItemMetrics to iImage
75011>>>>>        End
75011>>>>>>
75011>>>>>    End_Procedure
75012>>>>>    
75012>>>>>End_Class
75013>>>Use cCJGridColumn.pkg
75013>>>Use cChatGPTAPI.pkg
Including file: cChatGPTAPI.pkg    (C:\Projects\ChatGPTAPI\AppSrc\cChatGPTAPI.pkg)
75013>>>>>Use UI
75013>>>>>Use cHttpTransferREST.pkg
Including file: cHttpTransferREST.pkg    (C:\Projects\ChatGPTAPI\AppSrc\cHttpTransferREST.pkg)
75013>>>>>>>// Class: cHttpTransferREST
75013>>>>>>>//
75013>>>>>>>// An enhanced version of the cHttpTransfer class that stores received data
75013>>>>>>>// in a UChar array property (pucaData) (and also content type in psContentType).
75013>>>>>>>//
75013>>>>>>>// Provides a MakeJsonCall function for calling REST services.  OAuth2 is
75013>>>>>>>// assumed, as is JSON.
75013>>>>>>>//
75013>>>>>>>// The containing object (or a parent of it) is REQUIRED to provide the function
75013>>>>>>>// OAuth2AccessToken which should return the Access Token returned by the OAuth2
75013>>>>>>>// process.  (UNLESS pbRequireToken is set to False.)
75013>>>>>>>//
75013>>>>>>>// Revision:
75013>>>>>>>//     2023/03/07  (MJP, UIG)
75013>>>>>>>//        Added pbRequireToken to allow use in non-OAuth2 environments
75013>>>>>>>//        Added Extra headers (AddExtraHeader and ClearExtraHeaders) so you can
75013>>>>>>>//        add your own as required (i.e. you might do:
75013>>>>>>>//           AddExtraHeader "Authorization" "Basic: aGbfRfdfhgpRt4^fDDr4")
75013>>>>>>>//     2023/03/06  (MJP, UIG)
75013>>>>>>>//        Added the pbDefeatCaching property & if True (the default) will add
75013>>>>>>>//        a RandomHexUUID to the query string to do that, so that repeated calls
75013>>>>>>>//        to the same resource will get fresh results.
75013>>>>>>>//     2022/06/10  (MJP, UIG) 
75013>>>>>>>//        Initial version: 1.0
75013>>>>>>>//
75013>>>>>>>
75013>>>>>>>Use cHttpTransfer.pkg
75013>>>>>>>Use WinUuid.pkg
Including file: WinUuid.pkg    (C:\Program Files\DataFlex 23.0\Pkg\WinUuid.pkg)
75013>>>>>>>>>Use Unicode.Pkg
75013>>>>>>>>>
75013>>>>>>>>>External_Function WinAPI_UuidCreate "UuidCreate" Rpcrt4.dll ;    Pointer Uuid ;    Returns Integer
75014>>>>>>>>>
75014>>>>>>>>>External_Function WinAPI_UuidToString  "UuidToStringW" Rpcrt4.dll ;    Pointer pUuid ;    Pointer lpUUIDString ;    Returns Integer
75015>>>>>>>>>
75015>>>>>>>>>External_Function WinAPI_UuidCreateSequential "UuidCreateSequential" Rpcrt4.dll ;    Pointer pUuid ;    Returns Integer
75016>>>>>>>>>
75016>>>>>>>>>External_Function WinAPI_RpcStringFree "RpcStringFreeW" Rpcrt4.dll ;    Pointer pStr ;    Returns Integer
75017>>>>>>>>>
75017>>>>>>>>>
75017>>>>>>>>>// Returns a 'random' Universally Unique Identifier string as a 32 digit hex number.
75017>>>>>>>>>Function RandomHexUUID Global Returns String
75019>>>>>>>>>    Pointer pUUID pUUIDStr
75019>>>>>>>>>    Integer iRetval iOffset iChar
75019>>>>>>>>>    String sUUID
75019>>>>>>>>>    
75019>>>>>>>>>    Move (Alloc(16)) to pUUID
75020>>>>>>>>>    
75020>>>>>>>>>    Move (WinAPI_UuidCreate (pUUID)) to iRetval
75021>>>>>>>>>    
75021>>>>>>>>>    If (iRetval = 0) Begin
75023>>>>>>>>>        Move 0 to pUUIDStr
75024>>>>>>>>>        
75024>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75025>>>>>>>>>        If (iRetval = 0) Begin
75027>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75028>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75029>>>>>>>>>            
75029>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75030>>>>>>>>>        End
75030>>>>>>>>>>
75030>>>>>>>>>    End
75030>>>>>>>>>>
75030>>>>>>>>>    
75030>>>>>>>>>    Move (Free(pUUID)) to iRetval
75031>>>>>>>>>    
75031>>>>>>>>>    Function_Return sUUID
75032>>>>>>>>>End_Function
75033>>>>>>>>>
75033>>>>>>>>>
75033>>>>>>>>>// Returns a sequential Universally Unique Identifier string as a 32 digit hex number.
75033>>>>>>>>>Function SeqHexUUID Global Returns String
75035>>>>>>>>>    Pointer pUUID pUUIDStr
75035>>>>>>>>>    Integer iRetval iOffset iChar
75035>>>>>>>>>    String sUUID
75035>>>>>>>>>    
75035>>>>>>>>>    Move (Alloc(16)) to pUUID
75036>>>>>>>>>    
75036>>>>>>>>>    Move (WinAPI_UuidCreateSequential (pUUID)) to iRetval
75037>>>>>>>>>    
75037>>>>>>>>>    If (iRetval = 0) Begin
75039>>>>>>>>>        Move 0 to pUUIDStr
75040>>>>>>>>>        
75040>>>>>>>>>        Move (WinAPI_UuidToString (pUUID, AddressOf(pUUIDStr))) to iRetval
75041>>>>>>>>>        If (iRetval = 0) Begin
75043>>>>>>>>>            Move (PointerToWString(pUUIDStr)) to sUUID
75044>>>>>>>>>            Move (WinAPI_RpcStringFree (AddressOf (pUUIDStr))) to iRetval
75045>>>>>>>>>            
75045>>>>>>>>>            Move (Uppercase (sUUID)) to sUUID
75046>>>>>>>>>        End
75046>>>>>>>>>>
75046>>>>>>>>>    End
75046>>>>>>>>>>
75046>>>>>>>>>    
75046>>>>>>>>>    Move (Free(pUUID)) to iRetval
75047>>>>>>>>>    
75047>>>>>>>>>    Function_Return sUUID
75048>>>>>>>>>End_Function
75049>>>>>>>
75049>>>>>>>Enum_List
75049>>>>>>>    Define C_httpNoJson for -1
75049>>>>>>>    Define C_httpOK
75049>>>>>>>    Define C_httpCallFailed
75049>>>>>>>    Define C_httpBadStatus
75049>>>>>>>    Define C_httpJsonParseFail
75049>>>>>>>    Define C_httpNoAccessToken
75049>>>>>>>End_Enum_List
75049>>>>>>>
75049>>>>>>>// NOTE: This function MUST exist in an object parent in order to give objects
75049>>>>>>>//       of the class access to the AccessToken returned by the OAuth2 login
75049>>>>>>>//       process and MUST return that token!  (Unless you set pbRequireToken
75049>>>>>>>//       to False)
75049>>>>>>>Register_Function OAuth2AccessToken Returns String
75049>>>>>>>
75049>>>>>>>Class cHttpTransferREST is a cHttpTransfer
75050>>>>>>>    
75050>>>>>>>    Procedure Construct_Object
75052>>>>>>>        Forward Send Construct_Object
75054>>>>>>>        
75054>>>>>>>        Property UChar[]  pucaData
75055>>>>>>>        Property String   psContentType     ""
75056>>>>>>>        Property Integer  piError           C_httpOK  // Zero
75057>>>>>>>        Property String   psError           ""
75058>>>>>>>        Property String   psAcceptTypes     "*/*"
75059>>>>>>>        Property String   psSendType        "application/json"
75060>>>>>>>        Property Boolean  pbDefeatCaching   True
75061>>>>>>>        Property Boolean  pbRequireToken    True
75062>>>>>>>        Property String[] pasHeaderNames
75063>>>>>>>        Property String[] pasHeaderValues
75064>>>>>>>
75064>>>>>>>        Set piRemotePort    to rpHttpSSL
75065>>>>>>>        Set peTransferFlags to ifSecure
75066>>>>>>>    End_Procedure
75067>>>>>>>        
75067>>>>>>>    Procedure OnDataReceived String sContentType String sData
75069>>>>>>>        UChar[] ucaData
75070>>>>>>>        
75070>>>>>>>        Get pucaData        to ucaData
75071>>>>>>>        Set pucaData        to (AppendArray(ucaData, StringToUCharArray(sData)))
75072>>>>>>>        Set psContentType   to sContentType
75073>>>>>>>    End_Procedure
75074>>>>>>>    
75074>>>>>>>    Procedure AddExtraHeader String sName String sValue
75076>>>>>>>        String[] asNames asValues
75078>>>>>>>        Integer  iIdx iEnd
75078>>>>>>>        
75078>>>>>>>        Get pasHeaderNames to asNames
75079>>>>>>>        Move (SearchArray(asNames, sName)) to iIdx
75080>>>>>>>        
75080>>>>>>>        If (iIdx = -1) Begin  // Not already in array
75082>>>>>>>            Move (SizeOfArray(asNames)) to iEnd
75083>>>>>>>            Get pasHeaderValues         to asValues
75084>>>>>>>            Move sName                  to asNames[iEnd]
75085>>>>>>>            Move sValue                 to asValues[iEnd]
75086>>>>>>>            Set pasHeaderNames          to asNames
75087>>>>>>>            Set pasHeaderValues         to asValues
75088>>>>>>>        End
75088>>>>>>>>
75088>>>>>>>        
75088>>>>>>>    End_Procedure
75089>>>>>>>    
75089>>>>>>>    Procedure ClearExtraHeaders
75091>>>>>>>        String[] asEmpty
75092>>>>>>>        
75092>>>>>>>        Set pasHeaderNames  to asEmpty
75093>>>>>>>        Set pasHeaderValues to asEmpty
75094>>>>>>>    End_Procedure
75095>>>>>>>    
75095>>>>>>>    Procedure Reset
75097>>>>>>>        UChar[] empty
75098>>>>>>>        
75098>>>>>>>        Set pucaData        to empty
75099>>>>>>>        Set psContentType   to ""
75100>>>>>>>        Set piError         to C_httpOK  // Zero! ;-)
75101>>>>>>>        Set psError         to ""
75102>>>>>>>        Send ClearHeaders
75103>>>>>>>    End_Procedure
75104>>>>>>>    
75104>>>>>>>    Function psData Returns String
75106>>>>>>>        Function_Return (UCharArrayToString(pucaData(Self)))
75107>>>>>>>    End_Function
75108>>>>>>>    
75108>>>>>>>    Function MakeJsonCall String sVerb String sPath String sParams Handle hoBody Returns Handle
75110>>>>>>>        Handle   hoJson
75110>>>>>>>        Integer  iOK iStatus iHdrs i
75110>>>>>>>        Boolean  bOK
75110>>>>>>>        String   sData sBody sToken
75110>>>>>>>        String[] asHdrNames asHdrVals
75112>>>>>>>        
75112>>>>>>>        Move (Uppercase(sVerb)) to sVerb  // Probably not required ;-)
75113>>>>>>>        
75113>>>>>>>        Send Reset
75114>>>>>>>        
75114>>>>>>>        If (pbRequireToken(Self)) Begin
75116>>>>>>>            Get OAuth2AccessToken   to sToken
75117>>>>>>>        
75117>>>>>>>            If (sToken = "") Begin
75119>>>>>>>                Set piError to C_httpNoAccessToken
75120>>>>>>>                Set psError to "No OAuth2 access token"
75121>>>>>>>                Function_Return 0
75122>>>>>>>            End
75122>>>>>>>>
75122>>>>>>>            
75122>>>>>>>        End
75122>>>>>>>>
75122>>>>>>>        
75122>>>>>>>        // Add required headers:
75122>>>>>>>        Get AddHeader "Content-Type"      (psSendType(Self))    to iOK
75123>>>>>>>        Get AddHeader "Accept"            (psAcceptTypes(Self)) to iOK
75124>>>>>>>        If (sToken <> "") ;            Get AddHeader "Authorization" ("Bearer" * sToken)   to iOK
75127>>>>>>>        
75127>>>>>>>        // Deal with any extra headers
75127>>>>>>>        Get pasHeaderNames to asHdrNames
75128>>>>>>>        Move (SizeOfArray(asHdrNames)) to iHdrs
75129>>>>>>>         
75129>>>>>>>        If iHdrs Begin
75131>>>>>>>            Get pasHeaderValues to asHdrVals
75132>>>>>>>            Decrement iHdrs
75133>>>>>>>            
75133>>>>>>>            For i from 0 to iHdrs
75139>>>>>>>>
75139>>>>>>>                Get AddHeader asHdrNames[i] asHdrVals to iOK
75140>>>>>>>            Loop
75141>>>>>>>>
75141>>>>>>>            
75141>>>>>>>        End
75141>>>>>>>>
75141>>>>>>>        
75141>>>>>>>        // To defeat cacheing, we add a "nonce" set to a random hex UUID to the
75141>>>>>>>        // query string - after any real parameters we are passed, if any:
75141>>>>>>>        If (pbDefeatCaching(Self)) Begin
75143>>>>>>>            If (sParams = "") ;                Move (sPath + "?nonce=" + RandomHexUUID())                  to sPath
75146>>>>>>>            Else ;                Move (sPath + "?" + sParams + "&nonce=" + RandomHexUUID())  to sPath
75148>>>>>>>        End
75148>>>>>>>>
75148>>>>>>>        Else If (sParams <> "") ;            Move (sPath + "?" + sParams)                                    to sPath
75152>>>>>>>        
75152>>>>>>>        // Assumes that only POST, PUT and PATCH verbs will have a body:
75152>>>>>>>        If (((sVerb = "POST") or (sVerb = "PUT") or (sVerb = "PATCH")) and hoBody) Begin
75154>>>>>>>            Get Stringify of hoBody to sBody
75155>>>>>>>            Send Destroy of hoBody
75156>>>>>>>        End
75156>>>>>>>>
75156>>>>>>>        
75156>>>>>>>        // Make the call
75156>>>>>>>        Get HttpVerbAddrRequest sPath (AddressOf(sBody)) (SizeOfString(sBody)) False sVerb to iOK
75157>>>>>>>        
75157>>>>>>>        If iOK Begin
75159>>>>>>>            Get ResponseStatusCode  to iStatus
75160>>>>>>>            Get psData              to sData
75161>>>>>>>            
75161>>>>>>>            If ((iStatus >= 200) and (iStatus < 300)) Begin
75163>>>>>>>                
75163>>>>>>>                // If no JSON was returned, then return -1, indicating that, 
75163>>>>>>>                // which may be perfectly correct in some cases 
75163>>>>>>>                // (HTTP 204 - No Content, for instance).
75163>>>>>>>                If (SizeOfString(sData) < 2) ;  // 2 chars is the minimum JSON                    Function_Return C_httpNoJson
75166>>>>>>>
75166>>>>>>>                Get Create (RefClass(cJsonObject)) to hoJson
75167>>>>>>>                Set pbRequireAllMembers of hoJson to False
75168>>>>>>>                Set pbEscapeForwardSlash of hoJson to False
75169>>>>>>>                Get ParseString of hoJson sData to bOK
75170>>>>>>>                
75170>>>>>>>                If bOK ;                    Function_Return hoJson  // Success! Now caller's responsibility to destroy.
75173>>>>>>>                
75173>>>>>>>                // So if parsing failed:
75173>>>>>>>                Set piError to C_httpJsonParseFail
75174>>>>>>>                Set psError to ('Http Call to "' + psRemoteHost(Self) + '/' + sPath + "'" * ;                                'returned invalid JSON. Parse error:' * ;                                psParseError(hoJson))
75175>>>>>>>                Send Destroy of hoJson
75176>>>>>>>            End
75176>>>>>>>>
75176>>>>>>>            Else Begin  // Not a 2xx status
75177>>>>>>>                Set piError to C_httpBadStatus
75178>>>>>>>                Set psError to ('HTTP Call to "' + psRemoteHost(Self) + '/' + sPath + '"' * ;                                'returned a status of' * String(iStatus) * '-' * ;                                ResponseStatusText(Self) * ;                                "(" + sData + ")")
75179>>>>>>>            End
75179>>>>>>>>
75179>>>>>>>            
75179>>>>>>>        End
75179>>>>>>>>
75179>>>>>>>        Else Begin  // Call returned 0
75180>>>>>>>            Set piError to C_httpCallFailed
75181>>>>>>>            Set psError to ('HTTP Call to "' + psRemoteHost(Self) + '/' + sPath + '" failed')
75182>>>>>>>        End
75182>>>>>>>>
75182>>>>>>>        
75182>>>>>>>        Function_Return 0  // Indicates failure: check piError and psError for reason
75183>>>>>>>    End_Function
75184>>>>>>>    
75184>>>>>>>End_Class
75185>>>>>Use JsonPath.pkg
75185>>>>>
75185>>>>>Class cChatGPTAPI is a cObject
75186>>>>>    
75186>>>>>    Procedure Construct_Object
75188>>>>>        Forward Send Construct_Object
75190>>>>>    
75190>>>>>        Property String   psChatGPTBasePath "v1/"
75191>>>>>        
75191>>>>>        Object oHttp is a cHttpTransferREST
75193>>>>>            Set psRemoteHost    to "api.openai.com"
75194>>>>>            Set piRemotePort    to rpHttpSSL
75195>>>>>            Set peTransferFlags to ifSecure
75196>>>>>            Set pbDefeatCaching to False
75197>>>>>        End_Object
75198>>>>>        
75198>>>>>    End_Procedure
75199>>>>>    
75199>>>>>    Function AvailableModels Returns String[]
75201>>>>>        Handle   hoMods hoData
75201>>>>>        Integer  i iMax
75201>>>>>        String[] asModels
75202>>>>>        
75202>>>>>        Get MakeJsonCall of oHttp "GET" (psChatGPTBasePath(Self) + "models") "" 0 to hoMods
75203>>>>>            
75203>>>>>        If hoMods Begin
75205>>>>>                
75205>>>>>                If (HasMember(hoMods, "data")) Begin
75207>>>>>                    Get Member of hoMods "data" to hoData
75208>>>>>                    Get MemberCount of hoData to iMax
75209>>>>>                    Decrement iMax
75210>>>>>                    
75210>>>>>                    For i from 0 to iMax
75216>>>>>>
75216>>>>>                        Move (JsonValueAtPath(hoData, "[" + String(i) + "]id")) to asModels[i]
75217>>>>>                    Loop
75218>>>>>>
75218>>>>>                    
75218>>>>>                    Send Destroy of hoData
75219>>>>>                End
75219>>>>>>
75219>>>>>                
75219>>>>>                Send Destroy of hoMods
75220>>>>>            End
75220>>>>>>
75220>>>>>            
75220>>>>>            Function_Return asModels
75221>>>>>    End_Function
75222>>>>>    
75222>>>>>    Function Ask String sQuestion String sModel Returns String
75224>>>>>        Handle  hoBody hoMsg hoMsgs hoResp
75224>>>>>        String  sResp sMod
75224>>>>>        
75224>>>>>        Get Create (RefClass(cJsonObject)) to hoMsg
75225>>>>>        Send InitializeJsonType of hoMsg jsonTypeObject
75226>>>>>        Send SetMemberValue of hoMsg "role" jsonTypeString "user"
75227>>>>>        Send SetMemberValue of hoMsg "content" jsonTypeString (Trim(sQuestion))
75228>>>>>        
75228>>>>>        Get Create (RefClass(cJsonObject)) to hoMsgs
75229>>>>>        Send InitializeJsonType of hoMsgs jsonTypeArray
75230>>>>>        Send AddMember of hoMsgs hoMsg
75231>>>>>        Send Destroy of hoMsg
75232>>>>>        
75232>>>>>        Get Create (RefClass(cJsonObject)) to hoBody
75233>>>>>        Send InitializeJsonType of hoBody jsonTypeObject
75234>>>>>        Send SetMemberValue of hoBody "model" jsonTypeString (Trim(sModel))
75235>>>>>        Send SetMember of hoBody "messages" hoMsgs
75236>>>>>        Send Destroy of hoMsgs
75237>>>>>        
75237>>>>>        Get MakeJsonCall of oHttp "POST" (psChatGPTBasePath(Self) + "chat/completions") "" hoBody to hoResp
75238>>>>>        
75238>>>>>        If hoResp Begin
75240>>>>>            Move (JsonValueAtPath(hoResp, "choices[0].message.content")) to sResp
75241>>>>>            Send Destroy of hoResp
75242>>>>>        End
75242>>>>>>
75242>>>>>        
75242>>>>>        Function_Return sResp
75243>>>>>    End_Function
75244>>>>>
75244>>>>>End_Class
75245>>>
75245>>>Deferred_View Activate_oChatGPTTest for ;Object oChatGPTTest is a dbView
75270>>>    
75270>>>    Property String   psChatGPTBasePath "v1/"
75272>>>    
75272>>>    Property String[] pasSpeakers
75274>>>    Property String[] pasMessages
75276>>>    Property String[] pasTimes
75278>>>    
75278>>>    Set Border_Style to Border_Thick
75279>>>    Set Size to 340 628
75280>>>    Set Location to 2 2
75281>>>    Set Label to "ChatGPT Test View"
75282>>>    
75282>>>    Object oChatGPT is a cChatGPTAPI
75284>>>    End_Object
75285>>>    
75285>>>    Procedure AddToHistory String sSpeaker String sMsg
75288>>>        String[]   asSpeakers asMsgs asTimes
75291>>>        
75291>>>        Get pasSpeakers to asSpeakers
75292>>>        Get pasMessages to asMsgs
75293>>>        Get pasTimes    to asTimes
75294>>>        
75294>>>        Move sSpeaker               to asSpeakers[-1]
75295>>>        Move sMsg                   to asMsgs[-1]
75296>>>        Move (CurrentDateTime())    to asTimes[-1]
75297>>>        
75297>>>        Set pasSpeakers to asSpeakers
75298>>>        Set pasMessages to asMsgs
75299>>>        Set pasTimes    to asTimes
75300>>>        
75300>>>        Send ReloadHist of oHistory
75301>>>    End_Procedure
75302>>>    
75302>>>    Procedure AskChatGPT
75305>>>        String sAsk sResp sModel
75305>>>        
75305>>>        Send Cursor_Wait of oCursor
75306>>>        Get Value of oAsk       to sAsk
75307>>>        Get Value of oModels    to sModel
75308>>>        
75308>>>        Send AddToHistory "You" sAsk
75309>>>        
75309>>>        Get Ask of oChatGPT sAsk sModel to sResp
75310>>>        
75310>>>        If (sResp <> "") Begin
75312>>>            Set Value of oResponse to sResp
75313>>>            Send AddToHistory "ChatGPT" sResp
75314>>>        End
75314>>>>
75314>>>        Else Begin
75315>>>            Send AddToHistory "ChatGPT" "No response received"
75316>>>            Send Info_Box ("ChatGPT did not respond - there was probably a timeout. " + ;                           "\nPerhaps just try sending your question again") "ChatGPT Error"
75317>>>        End
75317>>>>
75317>>>        
75317>>>        Send Cursor_Ready of oCursor
75318>>>    End_Procedure
75319>>>    
75319>>>    Object oModels is a ComboForm
75321>>>        Set Size to 12 100
75322>>>        Set Location to 4 521
75323>>>        Set Label to "ChatGPT Model to use:"
75324>>>        Set Label_Justification_Mode to JMode_Right
75325>>>        Set Label_Col_Offset to 5
75326>>>        Set peAnchors to anTopRight
75327>>>    
75327>>>        Procedure Combo_Fill_List
75330>>>            Integer  i iMax
75330>>>            String[] asMods
75331>>>            
75331>>>            Get AvailableModels of oChatGPT to asMods
75332>>>            Move (SizeOfArray(asMods) - 1)  to iMax
75333>>>            
75333>>>            For i from 0 to iMax
75339>>>>
75339>>>                Send Combo_Add_Item asMods[i]
75340>>>            Loop
75341>>>>
75341>>>            
75341>>>            Set Value to "gpt-3.5-turbo"
75342>>>        End_Procedure
75343>>>      
75343>>>    End_Object
75344>>>
75344>>>    Object oAsk is a cTextEdit
75346>>>        Set Size to 36 554
75347>>>        Set Location to 28 10
75348>>>        Set Label to "Ask ChatGPT something:"
75349>>>        Set peAnchors to anTopLeftRight
75350>>>    End_Object
75351>>>
75351>>>    Object oSendBtn is a Button
75353>>>        Set Location to 28 571
75354>>>        Set Label to "Send"
75355>>>        Set peAnchors to anTopRight
75356>>>    
75356>>>        Procedure OnClick
75359>>>            Send AskChatGPT
75360>>>        End_Procedure
75361>>>    
75361>>>    End_Object
75362>>>
75362>>>    Object oClearBtn is a Button
75364>>>        Set Location to 46 571
75365>>>        Set Label to "Clear"
75366>>>        Set peAnchors to anTopRight
75367>>>    
75367>>>        Procedure OnClick
75370>>>            Set Value of oAsk to ""
75371>>>        End_Procedure
75372>>>    
75372>>>    End_Object
75373>>>
75373>>>    Object oResponse is a cTextEdit
75375>>>        Set Size to 128 610
75376>>>        Set Location to 77 10
75377>>>        Set Label to "ChatGPT replied:"
75378>>>        Set peAnchors to anAll
75379>>>    End_Object
75380>>>
75380>>>    Object oHistText is a TextBox
75382>>>        Set Size to 9 25
75383>>>        Set Location to 210 10
75384>>>        Set Label to "History:"
75385>>>        Set peAnchors to anBottomLeft
75386>>>    End_Object
75387>>>
75387>>>    Object oHistory is a cCJGrid
75389>>>        Set Size to 65 611
75390>>>        Set Location to 220 10
75391>>>        Set peAnchors to anBottomLeftRight
75392>>>        Set pbReadOnly to True
75393>>>
75393>>>        Object oCJGridColumnRowIndicator1 is a cCJGridColumnRowIndicator
75395>>>        End_Object
75396>>>
75396>>>        Object oDateTime is a cCJGridColumn
75398>>>            Set piWidth to 50
75399>>>            Set psCaption to "Time"
75400>>>        End_Object
75401>>>        
75401>>>        Object oSpeaker is a cCJGridColumn
75403>>>            Set piWidth to 20
75404>>>            Set psCaption to "Speaker"
75405>>>        End_Object
75406>>>
75406>>>        Object oMessage is a cCJGridColumn
75408>>>            Set piWidth to 350
75409>>>            Set psCaption to "Message"
75410>>>        End_Object
75411>>>
75411>>>        Procedure ReloadHist
75414>>>            tDataSourceRow[] atRows
75414>>>            tDataSourceRow[] atRows
75415>>>            Integer    iSpkCol iMsgCol iTimeCol i iMax
75415>>>            String[]   asSpeakers asMsgs asTimes
75418>>>            
75418>>>            Get pasSpeakers to asSpeakers
75419>>>            Get pasMessages to asMsgs
75420>>>            Get pasTimes    to asTimes
75421>>>            
75421>>>            Get piColumnID of oSpeaker  to iSpkCol
75422>>>            Get piColumnID of oMessage  to iMsgCol
75423>>>            Get piColumnID of oDateTime to iTimeCol
75424>>>            
75424>>>            Move (SizeOfArray(asSpeakers) - 1) to iMax
75425>>>            
75425>>>            For i from 0 to iMax
75431>>>>
75431>>>                Move asTimes[iMax - i]    to atRows[i].sValue[iTimeCol]
75432>>>                Move asSpeakers[iMax - i] to atRows[i].sValue[iSpkCol]
75433>>>                Move asMsgs[iMax - i]     to atRows[i].sValue[iMsgCol]
75434>>>            Loop
75435>>>>
75435>>>            
75435>>>            Send InitializeData atRows
75436>>>            Send MoveToFirstRow    
75437>>>        End_Procedure
75438>>>        
75438>>>        Procedure OnRowChanged Integer iOldRow Integer iNewSelectedRow
75441>>>            String[] asSpeakers asMsgs asTimes
75444>>>            Integer  iMax i
75444>>>            
75444>>>            Get pasSpeakers to asSpeakers
75445>>>            Get pasMessages to asMsgs
75446>>>            Get pasTimes    to asTimes
75447>>>            Move (SizeOfArray(asSpeakers) - 1) to iMax
75448>>>            Move (iMax - iNewSelectedRow) to i
75449>>>            
75449>>>            Set Value of oMsgContent to (Trim(asSpeakers[i]) * ;                                        "(at" * Trim(asTimes[i] + "):" * ;                                        Trim(asMsgs[i])))
75450>>>        End_Procedure
75451>>>        
75451>>>    End_Object
75452>>>
75452>>>    Object oMsgText is a TextBox
75454>>>        Set Size to 9 29
75455>>>        Set Location to 287 10
75456>>>        Set Label to "Message:"
75457>>>        Set peAnchors to anBottomLeft
75458>>>    End_Object
75459>>>
75459>>>    Object oMsgContent is a cTextEdit
75461>>>        Set Size to 40 611
75462>>>        Set Location to 297 10
75463>>>        Set peAnchors to anBottomLeftRight
75464>>>    End_Object
75465>>>
75465>>>Cd_End_Object
75467>>>>
75467>    End_Object
75468>
75468>End_Object
75469>
75469>Send Activate_oChatGPTTest of (oClientArea(oMain))
75470>Start_UI
75471>
Summary
Memory Available: 11558019072
Total Warnings : 0
Total Errors   : 0
Total Symbols  : 43462
Total Resources: 0
Total Commands : 75470
Total Windows  : 0
Total Pages    : 0
Static Data    : 544547
Message area   : 521428
Total Blocks   : 28354
